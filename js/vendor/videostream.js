/* This file is automatically generated. Do not edit it. */
(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

function CacheStream(e, t) {
  if (!(this instanceof CacheStream)) return new CacheStream(e, t);
  Readable.call(this);
  this.pos = e;
  this._file = t;
  this._file.stream = this;
  var i = t.minCache, r = t.cachefind(e);
  r < 0 && (r = -r - 1);
  t.mru++;
  for (;r < t.cachepos.length && i > 0; ) {
    e = t.cachepos[r++];
    i -= t.cache[e].byteLength;
    t.cachemru[e] = t.mru;
  }
}

function VideoFile(e) {
  this.data = e;
  this.stream = null;
  this.cache = Object.create(null);
  this.cachemru = Object.create(null);
  this.fetching = Object.create(null);
  this.cachepos = [];
  this.cachesize = 0;
  this.mru = 0;
  this.curfetch = 0;
  this.filesize = -1;
  this.throttle = 0;
  this.paused = !1;
  this.playing = !1;
  this.minCache = MIN_CACHE;
  this.maxCache = MAX_CACHE;
  if (e instanceof Blob) {
    this.minCache = 10485760;
    this.maxCache = 41943040;
    this.fetcher = this.fileReader;
  }
}

/**
 * Start streaming a MEGA file.
 * @param {String} data The data needed by gfsfetch()
 * @param {Object} video The <video> element
 * @constructor
 * @preserve
 */
function Streamer(e, t) {
  if (!(this instanceof Streamer)) return new Streamer(e, t);
  this.engine = ua.details.engine;
  this.browser = ua.details.browser;
  this._events = [ "progress", "timeupdate", "canplay", "pause", "playing", "error", "abort", "updateend", "ended" ];
  "Edge" !== this.browser && t.parentNode && !window.chrome && this._events.push("seeking");
  for (var i = this._events.length; i--; ) t.addEventListener(this._events[i], this, !1);
  this.video = t;
  this.evs = Object.create(null);
  this.file = new VideoFile(e);
  this.stream = new VideoStream(this.file.fetch(0), t, {
    bufferDuration: 1.8 * MAX_BUF_SECONDS
  });
  this.file._vs = this.stream;
}

var MAX_CACHE = 0 | localStorage.maxStreamingCache || 524288e3, MIN_CACHE = 0 | localStorage.minStreamingCache || 419430400, REQUEST_SIZE = 4194304, MAX_BUF_SECONDS = 25, VideoStream = require("../"), inherits = require("/bundle/utils").inherit, Readable = require("readable-stream").Readable, Buffer = require("buffer").Buffer;

inherits(CacheStream, Readable);

CacheStream.prototype._read = function(e) {
  e = window.chrome ? 1048576 : 262144;
  if (this._file && this._file._vs) {
    var t = this._file, i = t._vs, r = i._elem.currentTime, s = r && !t.seeking && i.bufTime;
    if (s > MAX_BUF_SECONDS) {
      t.throttle = r + s;
      d && console.debug("[CacheStream._read()] Max buffered seconds reached, throttling until %s (current playback time is %s)...", secondsToTime(t.throttle), secondsToTime(r));
    } else for (;e; ) {
      var a = t.cachefind(this.pos);
      if (a < 0) {
        t.fetch(this.pos);
        break;
      }
      var h = this.pos - (a = t.cachepos[a]), o = e;
      t.cache[a].byteLength - h < o && (o = t.cache[a].byteLength - h);
      if (o <= 0) break;
      e -= o;
      this.pos += o;
      t.cachemru[this.pos] = t.mru++;
      if (!this.push(Buffer.from(t.cache[a], h, o))) break;
    }
  }
};

CacheStream.prototype._destroy = function(e, t) {
  this._file.stream = !1;
  t(e);
};

VideoFile.prototype = Object.create(null);

VideoFile.prototype.createReadStream = function(e) {
  return new CacheStream(e.start || 0, this);
};

VideoFile.prototype.cachefind = function(e) {
  var t = this.cachepos.length;
  if (!t) return -1;
  if (e < this.cachepos[0]) return -1;
  for (var i = 0; ;) {
    var r = i + t >> 1;
    if (e >= this.cachepos[r]) {
      if (e < this.cachepos[r] + this.cache[this.cachepos[r]].byteLength) return r;
      i = r + 1;
    } else t = r;
    if (i == t) return -t - 1;
  }
};

VideoFile.prototype.cacheadd = function(e, t) {
  var i = this.cachefind(e);
  if (i >= 0) console.error("*** Mediacache: Internal error - clash"); else if ((i = -i - 1) < this.cachepos.length && e + t.byteLength > this.cachepos[i]) console.error("*** Mediacache: Internal error - overlap"); else {
    this.cachepos.splice(i, 0, e);
    this.cache[e] = t;
    this.cachemru[e] = this.mru++;
    this.cachesize += t.byteLength;
    if (this.cachesize > this.maxCache) {
      var r = this, s = this.cachepos.slice(0);
      s.sort(function(e, t) {
        return (r.cachemru[e] > r.cachemru[t]) - (r.cachemru[e] < r.cachemru[t]);
      });
      for (var a = 0; this.cachesize > this.minCache; a++) {
        var h = s[a];
        this.cachesize -= this.cache[h].byteLength;
        delete this.cache[h];
        delete this.cachemru[h];
        this.cachepos.splice(this.cachepos.indexOf(h), 1);
      }
    }
  }
};

VideoFile.prototype.fetcher = function(e, t, i) {
  return M.gfsfetch(e, t, i);
};

VideoFile.prototype.fileReader = function(e, t, i) {
  return new Promise(function(r, s) {
    var a = e.slice(t, i), h = new FileReader();
    h.onload = function() {
      r({
        buffer: h.result,
        s: e.size
      });
    };
    h.onerror = s;
    h.readAsArrayBuffer(a);
  });
};

VideoFile.prototype.fetch = function(e, t) {
  var i, r = this, s = e;
  if (t && this.paused && this.cachesize >= this.minCache) d && console.debug("[VideoFile.fetch()] MIN_CACHE reached, will not fetch more data until no longer %s...", this.paused ? "paused" : "throttled"); else if (void 0 !== this.mru) {
    this.curfetch += !t;
    var a;
    do {
      a = REQUEST_SIZE;
      for (;(i = this.cachefind(s)) >= 0; ) {
        s = this.cachepos[i] + this.cache[this.cachepos[i]].byteLength;
        a = 0;
      }
      for (;this.fetching[s]; ) {
        s += this.fetching[s];
        a = 0;
      }
    } while (!a);
    if ((i = -i - 1) < this.cachepos.length) {
      var h = this.cachepos[i] - s;
      h < a && (a = h);
    }
    for (i in this.fetching) {
      if (s >= (i *= 1) && s < i + this.fetching[i]) return;
      i >= s && i - s < a && (a = i - s);
    }
    this.filesize >= 0 && s + a >= this.filesize && (a = this.filesize - s);
    if (!(a < 1)) {
      this.fetching[s] = a;
      var o = this.curfetch;
      d && console.debug("Fetching %s-%s, length=%s...", s, s + a, a);
      this.fetcher(this.data, s, s + a).then(function(e) {
        var t = e.buffer;
        delete e.buffer;
        if (void 0 !== r.mru) {
          "string" == typeof r.data && (r.data = e);
          r.filesize < 0 && (r.filesize = e.s);
          delete r.fetching[s];
          r.cacheadd(s, t);
          s += t.byteLength;
          o === r.curfetch && setTimeout(r.fetch.bind(r, s, 1), 100);
          r.feedPlayer();
        }
      }).catch(function(i, a) {
        if (void 0 !== r.mru) {
          delete r.fetching[s];
          var h = function() {
            setImmediate(r.fetch.bind(r, e, t));
          };
          if ("number" == typeof i) (i !== ERANGE || s < a.s) && r._vs._onError(new Error(api_strerror(i))); else if (509 === i.target.status) {
            d && console.warn("stream overquota, holding...", i);
            dlmanager.showOverQuotaDialog(function() {
              dlmanager.onNolongerOverquota();
              h();
            });
          } else {
            d && console.warn("stream fetch error, retrying...", i);
            h();
          }
        }
      });
      return this;
    }
    a < 0 && console.error("*** Mediacache: Internal error - out of bound.", e, s, a);
  }
};

VideoFile.prototype.feedPlayer = function() {
  if (this.stream) try {
    this.stream._read(0);
  } catch (e) {
    this._vs._onError(e);
  }
};

Streamer.prototype = Object.create(null);

Streamer.prototype.destroy = function() {
  var e, t = Object.keys(this.file);
  d && console.debug("Destroying Streamer instance.", this);
  try {
    this.stream.destroy();
  } catch (e) {
    console.warn(e);
  }
  if (this.video) {
    for (e = this._events.length; e--; ) this.video.removeEventListener(this._events[e], this);
    if (this.video.parentNode) {
      var i = this.video, r = i.cloneNode(), s = i.parentNode;
      s.removeChild(i);
      s.appendChild(r);
    }
  }
  for (e = t.length; e--; ) delete this.file[t[e]];
  delete this.file;
  delete this.video;
};

Streamer.prototype.handleEvent = function(e) {
  var t = e.target, i = this.file;
  (d && "timeupdate" !== e.type || d > 1) && console.debug("Event(%s)", e.type, t, e);
  switch (e.type) {
   case "seeking":
    i.seeking = !0;
    this.stream.flushSourceBuffers();
    this.video.paused && onIdle(this.play.bind(this));

   case "playing":
    if (i.paused) {
      i.paused = !1;
      if (i.stream) {
        d && console.debug("Was paused, continuing fetching data...");
        i.fetch(i.stream.pos);
      }
    }
    if ("playing" === e.type) {
      i.playing = !0;
      i.seeking = !1;
    }
    break;

   case "pause":
    i.paused = !0;
    i.playing = !1;
    break;

   case "canplay":
    this.play();
    break;

   case "progress":
    t.removeEventListener("progress", this);
    i.playing || this.play();
    break;

   case "timeupdate":
    if (i.throttle && i.throttle - t.currentTime < MAX_BUF_SECONDS / 3) {
      d && console.debug("[Streamer.timeupdate] Throttle threshold %s reached at playback time %s, resuming...", secondsToTime(i.throttle), secondsToTime(t.currentTime), !!i.stream);
      i.throttle = 0;
      i.stream && i.stream._read(0);
    }
  }
  if (this.evs[e.type]) {
    var r = "error" === e.type && this.stream.detailedError || !1;
    this.evs[e.type] = this.evs[e.type].filter(function(t) {
      return t(e, r);
    });
    this.evs[e.type].length || delete this.evs[e.type];
  }
};

Streamer.prototype.play = function() {
  try {
    var e = this.video, t = e.play();
    "undefined" != typeof Promise && t instanceof Promise && t.then(function() {
      d && console.debug("Playing, current time: %s, duration: %s", secondsToTime(e.currentTime), secondsToTime(e.duration));
    }).catch(function(e) {
      d && console.debug("video.play() failed...", e);
    });
  } catch (e) {}
};

Streamer.prototype.on = function(e, t, i) {
  t = tryCatch(t.bind(this), i);
  this.evs[e] ? this.evs[e].push(t) : this.evs[e] = [ t ];
  return this;
};

Streamer.prototype.getImage = function(e, t) {
  var i = this, r = this.video;
  return new Promise(function _(s, a) {
    if (!r.videoWidth) return a(-9);
    var h = i.dim(r.videoWidth, r.videoHeight, e || 1280, t || 720);
    d && console.debug("[Streamer.getImage()] Taking %sx%s image from %sx%s at %s", h.width, h.height, r.videoWidth, r.videoHeight, secondsToTime(r.currentTime));
    var o = document.createElement("canvas"), n = o.getContext("2d");
    o.width = Math.round(h.width);
    o.height = Math.round(h.height);
    n.drawImage(r, 0, 0, o.width, o.height);
    for (var c, f = n.getImageData(0, 0, o.width, o.height).data, l = c = f.byteLength, u = 0; c--; ) f[c] < 10 && u++;
    if (Math.round(100 * u / l) > 70) {
      d && console.debug("[Streamer.getImage()] Got +70% of black pixels, retrying...");
      r.paused ? a(-5) : r.ended ? a(-8) : setTimeout(_.bind(this, s, a), 800);
    } else s(dataURLToAB(o.toDataURL("image/png")));
  });
};

Streamer.prototype.dim = function(e, t, i, r) {
  var s = Math.min(i / e, r / t);
  return {
    width: e * s,
    height: t * s,
    ratio: s
  };
};

Streamer.getThumbnail = function(e) {
  return new Promise(function(t, i) {
    var r = document.createElement("video");
    r.muted = !0;
    var s = -1, a = Streamer(e, r), h = function(e) {
      a.destroy();
      i(e);
    };
    a.on("playing", function() {
      if (!++s) {
        r.currentTime = 20 * r.duration / 100;
        return !0;
      }
      a.getImage().then(function(e) {
        t(e);
        a.destroy();
      }).catch(h);
    });
    a.on("error", h);
  });
};

/**
 *  @global
 *  @preserve
 *  @name Streamer
 */
Object.defineProperty(self, "Streamer", {
  value: Object.freeze(Streamer)
});
},{"../":34,"/bundle/utils":2,"buffer":6,"readable-stream":29}],2:[function(require,module,exports){
var Buffer = require("buffer").Buffer, onNextTick = function(e) {
  setTimeout(e, 0);
};

"undefined" != typeof requestIdleCallback && (onNextTick = function(e) {
  requestIdleCallback(function() {
    e();
  }, {
    timeout: 10
  });
});

var utils = {
  debuglog: function(e) {
    if (d > 2) {
      var t = MegaLogger.getLogger(e);
      return t.debug.bind(t);
    }
    return function() {};
  },
  nextTick: function() {
    var e = arguments[0];
    if (arguments.length > 1) {
      arguments[0] = null;
      onNextTick(Function.prototype.bind.apply(e, arguments));
    } else onNextTick(e);
  },
  inherit: function(e, t) {
    e.super_ = t;
    e.prototype = Object.create(t.prototype, {
      constructor: {
        value: e,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    });
  },
  deprecate: function(e, t) {
    var n = !1;
    return function() {
      if (!n) {
        n = !0;
        console.warn(t);
      }
      return e.apply(this, arguments);
    };
  },
  isU8: function(e) {
    return e instanceof Uint8Array || Buffer.isBuffer(e);
  }
};

module.exports = utils;
},{"buffer":6}],3:[function(require,module,exports){
function MP4Remuxer(e) {
  EventEmitter.call(this);
  this._tracks = [];
  this._fragmentSequence = 1;
  this._file = e;
  this._decoder = null;
  this._findMoov(0);
}

function RunLengthIndex(e, t) {
  this._entries = e;
  this._countName = t || "count";
  this._index = 0;
  this._offset = 0;
  this.value = this._entries[0];
}

function empty() {
  return {
    version: 0,
    flags: 0,
    entries: []
  };
}

var bs = require("binary-search"), EventEmitter = require("events").EventEmitter, inherits = require("/bundle/utils").inherit, mp4 = require("mp4-stream"), Box = require("mp4-box-encoding"), RangeSliceStream = require("range-slice-stream"), Buffer = require("buffer").Buffer;

module.exports = MP4Remuxer;

inherits(MP4Remuxer, EventEmitter);

MP4Remuxer.prototype._findMoov = function(e) {
  var t = this;
  t._decoder && t._decoder.destroy();
  t._decoder = mp4.decode();
  var r = t._file.createReadStream({
    start: e
  });
  r.pipe(t._decoder);
  t._decoder.once("box", function(s) {
    d && console.debug("box", s.type, s.length, s, e);
    if ("moov" === s.type) t._decoder.decode(function(e) {
      r.destroy();
      try {
        t._processMoov(e);
      } catch (e) {
        e.message = "Cannot parse mp4 file: " + e.message;
        t.emit("error", e);
      }
    }); else {
      r.destroy();
      t._findMoov(e + s.length);
    }
  });
};

RunLengthIndex.prototype.inc = function() {
  this._offset++;
  if (this._offset >= this._entries[this._index][this._countName]) {
    this._index++;
    this._offset = 0;
  }
  this.value = this._entries[this._index];
};

MP4Remuxer.prototype._processMoov = function(e) {
  var t = e.traks;
  this._tracks = [];
  this._hasVideo = !1;
  this._hasAudio = !1;
  for (var r = 0; r < t.length; r++) {
    var s, i, n = t[r], a = n.mdia.minf.stbl, o = a.stco || a.co64, d = a.stsd.entries[0], m = n.mdia.hdlr.handlerType;
    if ("vide" === m && "avc1" === d.type) {
      if (this._hasVideo) continue;
      this._hasVideo = !0;
      s = "avc1";
      d.avcC && (s += "." + d.avcC.mimeCodec);
      i = 'video/mp4; codecs="' + s + '"';
    } else {
      if ("soun" !== m || "mp4a" !== d.type) continue;
      if (this._hasAudio) continue;
      this._hasAudio = !0;
      s = "mp4a";
      d.esds && d.esds.mimeCodec && (s += "." + d.esds.mimeCodec);
      i = 'audio/mp4; codecs="' + s + '"';
    }
    var f = [], c = 0, u = 0, h = 0, l = 0, p = 0, _ = 0, v = new RunLengthIndex(a.stts.entries), g = null;
    a.ctts && (g = new RunLengthIndex(a.ctts.entries));
    for (var y = 0; ;) {
      var S = a.stsc.entries[p], x = a.stsz.entries[c], k = v.value.duration, M = !0;
      a.stss && (M = a.stss.entries[y] === c + 1);
      f.push({
        size: x,
        duration: k,
        dts: _,
        presentationOffset: g ? g.value.compositionOffset : 0,
        sync: M,
        offset: l + o.entries[h]
      });
      if (++c >= a.stsz.entries.length) break;
      l += x;
      if (++u >= S.samplesPerChunk) {
        u = 0;
        l = 0;
        h++;
        var b = a.stsc.entries[p + 1];
        b && h + 1 >= b.firstChunk && p++;
      }
      _ += k;
      v.inc();
      g && g.inc();
      M && y++;
    }
    n.mdia.mdhd.duration = 0;
    n.tkhd.duration = 0;
    var I = S.sampleDescriptionId, R = {
      type: "moov",
      mvhd: e.mvhd,
      traks: [ {
        tkhd: n.tkhd,
        mdia: {
          mdhd: n.mdia.mdhd,
          hdlr: n.mdia.hdlr,
          elng: n.mdia.elng,
          minf: {
            vmhd: n.mdia.minf.vmhd,
            smhd: n.mdia.minf.smhd,
            dinf: n.mdia.minf.dinf,
            stbl: {
              stsd: a.stsd,
              stts: empty(),
              ctts: empty(),
              stsc: empty(),
              stsz: empty(),
              stco: empty(),
              stss: empty()
            }
          }
        }
      } ],
      mvex: {
        mehd: {
          fragmentDuration: e.mvhd.duration
        },
        trexs: [ {
          trackId: n.tkhd.trackId,
          defaultSampleDescriptionIndex: I,
          defaultSampleDuration: 0,
          defaultSampleSize: 0,
          defaultSampleFlags: 0
        } ]
      }
    };
    this._tracks.push({
      trackId: n.tkhd.trackId,
      timeScale: n.mdia.mdhd.timeScale,
      samples: f,
      currSample: null,
      currTime: null,
      moov: R,
      mime: i
    });
  }
  if (0 !== this._tracks.length) {
    e.mvhd.duration = 0;
    this._ftyp = {
      type: "ftyp",
      brand: "iso5",
      brandVersion: 0,
      compatibleBrands: [ "iso5" ]
    };
    var B = Box.encode(this._ftyp), E = this._tracks.map(function(e) {
      var t = Box.encode(e.moov);
      return {
        mime: e.mime,
        init: Buffer.concat([ B, t ])
      };
    });
    this.emit("ready", E);
  } else this.emit("error", new Error("no playable tracks"));
};

MP4Remuxer.prototype.seek = function(e) {
  var t = this;
  if (!t._tracks) throw new Error("Not ready yet; wait for 'ready' event");
  if (t._fileStream) {
    t._fileStream.destroy();
    t._fileStream = null;
  }
  var r = -1;
  t._tracks.map(function(s, i) {
    function writeFragment(e) {
      n.destroyed || n.box(e.moof, function(r) {
        if (r) return t.emit("error", r);
        n.destroyed || s.inStream.slice(e.ranges).pipe(n.mediaData(e.length, function(e) {
          if (e) return t.emit("error", e);
          if (!n.destroyed) {
            var r = t._generateFragment(i);
            if (!r) return n.finalize();
            writeFragment(r);
          }
        }));
      });
    }
    s.outStream && s.outStream.destroy();
    if (s.inStream) {
      s.inStream.destroy();
      s.inStream = null;
    }
    var n = s.outStream = mp4.encode(), a = t._generateFragment(i, e);
    if (!a) return n.finalize();
    (-1 === r || a.ranges[0].start < r) && (r = a.ranges[0].start);
    writeFragment(a);
  });
  if (r >= 0) {
    var s = t._fileStream = t._file.createReadStream({
      start: r
    });
    t._tracks.forEach(function(e) {
      e.inStream = new RangeSliceStream(r, {
        highWaterMark: 1e7
      });
      s.pipe(e.inStream);
    });
  }
  return t._tracks.map(function(e) {
    return e.outStream;
  });
};

MP4Remuxer.prototype._findSampleBefore = function(e, t) {
  var r = this._tracks[e], s = Math.floor(r.timeScale * t), i = bs(r.samples, s, function(e, t) {
    return e.dts + e.presentationOffset - t;
  });
  -1 === i ? i = 0 : i < 0 && (i = -i - 2);
  if (i < 1) return 0;
  for (;!r.samples[i].sync; ) i--;
  return i;
};

var MIN_FRAGMENT_DURATION = 1;

MP4Remuxer.prototype._generateFragment = function(e, t) {
  var r, s = this._tracks[e];
  if ((r = void 0 !== t ? this._findSampleBefore(e, t) : s.currSample) >= s.samples.length) return null;
  for (var i = s.samples[r].dts, n = 0, a = [], o = r; o < s.samples.length; o++) {
    var d = s.samples[o];
    if (d.sync && d.dts - i >= s.timeScale * MIN_FRAGMENT_DURATION) break;
    n += d.size;
    var m = a.length - 1;
    m < 0 || a[m].end !== d.offset ? a.push({
      start: d.offset,
      end: d.offset + d.size
    }) : a[m].end += d.size;
  }
  s.currSample = o;
  return {
    moof: this._generateMoof(e, r, o),
    ranges: a,
    length: n
  };
};

MP4Remuxer.prototype._generateMoof = function(e, t, r) {
  for (var s = this._tracks[e], i = [], n = t; n < r; n++) {
    var a = s.samples[n];
    i.push({
      sampleDuration: a.duration,
      sampleSize: a.size,
      sampleFlags: a.sync ? 33554432 : 16842752,
      sampleCompositionTimeOffset: a.presentationOffset
    });
  }
  var o = {
    type: "moof",
    mfhd: {
      sequenceNumber: this._fragmentSequence++
    },
    trafs: [ {
      tfhd: {
        flags: 131072,
        trackId: s.trackId
      },
      tfdt: {
        baseMediaDecodeTime: s.samples[t].dts
      },
      trun: {
        flags: 3841,
        dataOffset: 8,
        entries: i
      }
    } ]
  };
  o.trafs[0].trun.dataOffset += Box.encodingLength(o);
  return o;
};

var UINT32_MAX = Math.pow(2, 32);

Box.boxes.fullBoxes.co64 = !0;

Box.boxes.co64 = {};

Box.boxes.co64.decode = function(e, t) {
  for (var r = (e = e.slice(t)).readUInt32BE(0), s = new Array(r), i = 0; i < r; i++) {
    var n = 8 * i + 4, a = e.readUInt32BE(n), o = e.readUInt32BE(n + 4);
    s[i] = a * UINT32_MAX + o;
  }
  return {
    entries: s
  };
};
},{"/bundle/utils":2,"binary-search":5,"buffer":6,"events":8,"mp4-box-encoding":13,"mp4-stream":16,"range-slice-stream":20}],4:[function(require,module,exports){
"use strict";

function placeHoldersCount(o) {
  var r = o.length;
  if (r % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
  return "=" === o[r - 2] ? 2 : "=" === o[r - 1] ? 1 : 0;
}

function byteLength(o) {
  return 3 * o.length / 4 - placeHoldersCount(o);
}

function toByteArray(o) {
  var r, e, t, u, n, p = o.length;
  u = placeHoldersCount(o);
  n = new Arr(3 * p / 4 - u);
  e = u > 0 ? p - 4 : p;
  var a = 0;
  for (r = 0; r < e; r += 4) {
    t = revLookup[o.charCodeAt(r)] << 18 | revLookup[o.charCodeAt(r + 1)] << 12 | revLookup[o.charCodeAt(r + 2)] << 6 | revLookup[o.charCodeAt(r + 3)];
    n[a++] = t >> 16 & 255;
    n[a++] = t >> 8 & 255;
    n[a++] = 255 & t;
  }
  if (2 === u) {
    t = revLookup[o.charCodeAt(r)] << 2 | revLookup[o.charCodeAt(r + 1)] >> 4;
    n[a++] = 255 & t;
  } else if (1 === u) {
    t = revLookup[o.charCodeAt(r)] << 10 | revLookup[o.charCodeAt(r + 1)] << 4 | revLookup[o.charCodeAt(r + 2)] >> 2;
    n[a++] = t >> 8 & 255;
    n[a++] = 255 & t;
  }
  return n;
}

function tripletToBase64(o) {
  return lookup[o >> 18 & 63] + lookup[o >> 12 & 63] + lookup[o >> 6 & 63] + lookup[63 & o];
}

function encodeChunk(o, r, e) {
  for (var t = [], u = r; u < e; u += 3) t.push(tripletToBase64((o[u] << 16) + (o[u + 1] << 8) + o[u + 2]));
  return t.join("");
}

function fromByteArray(o) {
  for (var r, e = o.length, t = e % 3, u = "", n = [], p = 0, a = e - t; p < a; p += 16383) n.push(encodeChunk(o, p, p + 16383 > a ? a : p + 16383));
  if (1 === t) {
    u += lookup[(r = o[e - 1]) >> 2];
    u += lookup[r << 4 & 63];
    u += "==";
  } else if (2 === t) {
    u += lookup[(r = (o[e - 2] << 8) + o[e - 1]) >> 10];
    u += lookup[r >> 4 & 63];
    u += lookup[r << 2 & 63];
    u += "=";
  }
  n.push(u);
  return n.join("");
}

exports.byteLength = byteLength;

exports.toByteArray = toByteArray;

exports.fromByteArray = fromByteArray;

for (var lookup = [], revLookup = [], Arr = "undefined" != typeof Uint8Array ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}

revLookup["-".charCodeAt(0)] = 62;

revLookup["_".charCodeAt(0)] = 63;
},{}],5:[function(require,module,exports){
module.exports = function(e, r, n, i, o) {
  var l, t;
  if (void 0 === i) i = 0; else if ((i |= 0) < 0 || i >= e.length) throw new RangeError("invalid lower bound");
  if (void 0 === o) o = e.length - 1; else if ((o |= 0) < i || o >= e.length) throw new RangeError("invalid upper bound");
  for (;i <= o; ) if ((t = +n(e[l = i + (o - i >> 1)], r, l, e)) < 0) i = l + 1; else {
    if (!(t > 0)) return l;
    o = l - 1;
  }
  return ~i;
};
},{}],6:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
"use strict";

function typedArraySupport() {
  try {
    var e = new Uint8Array(1);
    e.__proto__ = {
      __proto__: Uint8Array.prototype,
      foo: function() {
        return 42;
      }
    };
    return 42 === e.foo();
  } catch (e) {
    return !1;
  }
}

function createBuffer(e) {
  if (e > K_MAX_LENGTH) throw new RangeError("Invalid typed array length");
  var t = new Uint8Array(e);
  t.__proto__ = Buffer.prototype;
  return t;
}

function Buffer(e, t, r) {
  if ("number" == typeof e) {
    if ("string" == typeof t) throw new Error("If encoding is specified then the first argument must be a string");
    return allocUnsafe(e);
  }
  return from(e, t, r);
}

function from(e, t, r) {
  if ("number" == typeof e) throw new TypeError('"value" argument must not be a number');
  return isArrayBuffer(e) ? fromArrayBuffer(e, t, r) : "string" == typeof e ? fromString(e, t) : fromObject(e);
}

function assertSize(e) {
  if ("number" != typeof e) throw new TypeError('"size" argument must be a number');
  if (e < 0) throw new RangeError('"size" argument must not be negative');
}

function alloc(e, t, r) {
  assertSize(e);
  return e <= 0 ? createBuffer(e) : void 0 !== t ? "string" == typeof r ? createBuffer(e).fill(t, r) : createBuffer(e).fill(t) : createBuffer(e);
}

function allocUnsafe(e) {
  assertSize(e);
  return createBuffer(e < 0 ? 0 : 0 | checked(e));
}

function fromString(e, t) {
  "string" == typeof t && "" !== t || (t = "utf8");
  if (!Buffer.isEncoding(t)) throw new TypeError('"encoding" must be a valid string encoding');
  var r = 0 | byteLength(e, t), n = createBuffer(r), f = n.write(e, t);
  f !== r && (n = n.slice(0, f));
  return n;
}

function fromArrayLike(e) {
  for (var t = e.length < 0 ? 0 : 0 | checked(e.length), r = createBuffer(t), n = 0; n < t; n += 1) r[n] = 255 & e[n];
  return r;
}

function fromArrayBuffer(e, t, r) {
  if (t < 0 || e.byteLength < t) throw new RangeError("'offset' is out of bounds");
  if (e.byteLength < t + (r || 0)) throw new RangeError("'length' is out of bounds");
  var n;
  (n = void 0 === t && void 0 === r ? new Uint8Array(e) : void 0 === r ? new Uint8Array(e, t) : new Uint8Array(e, t, r)).__proto__ = Buffer.prototype;
  return n;
}

function fromObject(e) {
  if (Buffer.isBuffer(e)) {
    var t = 0 | checked(e.length), r = createBuffer(t);
    if (0 === r.length) return r;
    e.copy(r, 0, 0, t);
    return r;
  }
  if (e) {
    if (isArrayBufferView(e) || "length" in e) return "number" != typeof e.length || numberIsNaN(e.length) ? createBuffer(0) : fromArrayLike(e);
    if ("Buffer" === e.type && Array.isArray(e.data)) return fromArrayLike(e.data);
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}

function checked(e) {
  if (e >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
  return 0 | e;
}

function SlowBuffer(e) {
  +e != e && (e = 0);
  return Buffer.alloc(+e);
}

function byteLength(e, t) {
  if (Buffer.isBuffer(e)) return e.length;
  if (isArrayBufferView(e) || isArrayBuffer(e)) return e.byteLength;
  "string" != typeof e && (e = "" + e);
  var r = e.length;
  if (0 === r) return 0;
  for (var n = !1; ;) switch (t) {
   case "ascii":
   case "latin1":
   case "binary":
    return r;

   case "utf8":
   case "utf-8":
   case void 0:
    return utf8ToBytes(e).length;

   case "ucs2":
   case "ucs-2":
   case "utf16le":
   case "utf-16le":
    return 2 * r;

   case "hex":
    return r >>> 1;

   case "base64":
    return base64ToBytes(e).length;

   default:
    if (n) return utf8ToBytes(e).length;
    t = ("" + t).toLowerCase();
    n = !0;
  }
}

function slowToString(e, t, r) {
  var n = !1;
  (void 0 === t || t < 0) && (t = 0);
  if (t > this.length) return "";
  (void 0 === r || r > this.length) && (r = this.length);
  if (r <= 0) return "";
  if ((r >>>= 0) <= (t >>>= 0)) return "";
  e || (e = "utf8");
  for (;;) switch (e) {
   case "hex":
    return hexSlice(this, t, r);

   case "utf8":
   case "utf-8":
    return utf8Slice(this, t, r);

   case "ascii":
    return asciiSlice(this, t, r);

   case "latin1":
   case "binary":
    return latin1Slice(this, t, r);

   case "base64":
    return base64Slice(this, t, r);

   case "ucs2":
   case "ucs-2":
   case "utf16le":
   case "utf-16le":
    return utf16leSlice(this, t, r);

   default:
    if (n) throw new TypeError("Unknown encoding: " + e);
    e = (e + "").toLowerCase();
    n = !0;
  }
}

function swap(e, t, r) {
  var n = e[t];
  e[t] = e[r];
  e[r] = n;
}

function bidirectionalIndexOf(e, t, r, n, f) {
  if (0 === e.length) return -1;
  if ("string" == typeof r) {
    n = r;
    r = 0;
  } else r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648);
  numberIsNaN(r = +r) && (r = f ? 0 : e.length - 1);
  r < 0 && (r = e.length + r);
  if (r >= e.length) {
    if (f) return -1;
    r = e.length - 1;
  } else if (r < 0) {
    if (!f) return -1;
    r = 0;
  }
  "string" == typeof t && (t = Buffer.from(t, n));
  if (Buffer.isBuffer(t)) return 0 === t.length ? -1 : arrayIndexOf(e, t, r, n, f);
  if ("number" == typeof t) {
    t &= 255;
    return "function" == typeof Uint8Array.prototype.indexOf ? f ? Uint8Array.prototype.indexOf.call(e, t, r) : Uint8Array.prototype.lastIndexOf.call(e, t, r) : arrayIndexOf(e, [ t ], r, n, f);
  }
  throw new TypeError("val must be string, number or Buffer");
}

function arrayIndexOf(e, t, r, n, f) {
  function read(e, t) {
    return 1 === i ? e[t] : e.readUInt16BE(t * i);
  }
  var i = 1, o = e.length, u = t.length;
  if (void 0 !== n && ("ucs2" === (n = String(n).toLowerCase()) || "ucs-2" === n || "utf16le" === n || "utf-16le" === n)) {
    if (e.length < 2 || t.length < 2) return -1;
    i = 2;
    o /= 2;
    u /= 2;
    r /= 2;
  }
  var s;
  if (f) {
    var a = -1;
    for (s = r; s < o; s++) if (read(e, s) === read(t, -1 === a ? 0 : s - a)) {
      -1 === a && (a = s);
      if (s - a + 1 === u) return a * i;
    } else {
      -1 !== a && (s -= s - a);
      a = -1;
    }
  } else {
    r + u > o && (r = o - u);
    for (s = r; s >= 0; s--) {
      for (var h = !0, c = 0; c < u; c++) if (read(e, s + c) !== read(t, c)) {
        h = !1;
        break;
      }
      if (h) return s;
    }
  }
  return -1;
}

function hexWrite(e, t, r, n) {
  r = Number(r) || 0;
  var f = e.length - r;
  n ? (n = Number(n)) > f && (n = f) : n = f;
  var i = t.length;
  if (i % 2 != 0) throw new TypeError("Invalid hex string");
  n > i / 2 && (n = i / 2);
  for (var o = 0; o < n; ++o) {
    var u = parseInt(t.substr(2 * o, 2), 16);
    if (numberIsNaN(u)) return o;
    e[r + o] = u;
  }
  return o;
}

function utf8Write(e, t, r, n) {
  return blitBuffer(utf8ToBytes(t, e.length - r), e, r, n);
}

function asciiWrite(e, t, r, n) {
  return blitBuffer(asciiToBytes(t), e, r, n);
}

function latin1Write(e, t, r, n) {
  return asciiWrite(e, t, r, n);
}

function base64Write(e, t, r, n) {
  return blitBuffer(base64ToBytes(t), e, r, n);
}

function ucs2Write(e, t, r, n) {
  return blitBuffer(utf16leToBytes(t, e.length - r), e, r, n);
}

function base64Slice(e, t, r) {
  return base64.fromByteArray(0 === t && r === e.length ? e : e.slice(t, r));
}

function utf8Slice(e, t, r) {
  r = Math.min(e.length, r);
  for (var n = [], f = t; f < r; ) {
    var i = e[f], o = null, u = i > 239 ? 4 : i > 223 ? 3 : i > 191 ? 2 : 1;
    if (f + u <= r) {
      var s, a, h, c;
      switch (u) {
       case 1:
        i < 128 && (o = i);
        break;

       case 2:
        128 == (192 & (s = e[f + 1])) && (c = (31 & i) << 6 | 63 & s) > 127 && (o = c);
        break;

       case 3:
        a = e[f + 2];
        128 == (192 & (s = e[f + 1])) && 128 == (192 & a) && (c = (15 & i) << 12 | (63 & s) << 6 | 63 & a) > 2047 && (c < 55296 || c > 57343) && (o = c);
        break;

       case 4:
        a = e[f + 2];
        h = e[f + 3];
        128 == (192 & (s = e[f + 1])) && 128 == (192 & a) && 128 == (192 & h) && (c = (15 & i) << 18 | (63 & s) << 12 | (63 & a) << 6 | 63 & h) > 65535 && c < 1114112 && (o = c);
      }
    }
    if (null === o) {
      o = 65533;
      u = 1;
    } else if (o > 65535) {
      n.push((o -= 65536) >>> 10 & 1023 | 55296);
      o = 56320 | 1023 & o;
    }
    n.push(o);
    f += u;
  }
  return decodeCodePointsArray(n);
}

function decodeCodePointsArray(e) {
  var t = e.length;
  if (t <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, e);
  for (var r = "", n = 0; n < t; ) r += String.fromCharCode.apply(String, e.slice(n, n += MAX_ARGUMENTS_LENGTH));
  return r;
}

function asciiSlice(e, t, r) {
  var n = "";
  r = Math.min(e.length, r);
  for (var f = t; f < r; ++f) n += String.fromCharCode(127 & e[f]);
  return n;
}

function latin1Slice(e, t, r) {
  var n = "";
  r = Math.min(e.length, r);
  for (var f = t; f < r; ++f) n += String.fromCharCode(e[f]);
  return n;
}

function hexSlice(e, t, r) {
  var n = e.length;
  (!t || t < 0) && (t = 0);
  (!r || r < 0 || r > n) && (r = n);
  for (var f = "", i = t; i < r; ++i) f += toHex(e[i]);
  return f;
}

function utf16leSlice(e, t, r) {
  for (var n = e.slice(t, r), f = "", i = 0; i < n.length; i += 2) f += String.fromCharCode(n[i] + 256 * n[i + 1]);
  return f;
}

function checkOffset(e, t, r) {
  if (e % 1 != 0 || e < 0) throw new RangeError("offset is not uint");
  if (e + t > r) throw new RangeError("Trying to access beyond buffer length");
}

function checkInt(e, t, r, n, f, i) {
  if (!Buffer.isBuffer(e)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (t > f || t < i) throw new RangeError('"value" argument is out of bounds');
  if (r + n > e.length) throw new RangeError("Index out of range");
}

function checkIEEE754(e, t, r, n, f, i) {
  if (r + n > e.length) throw new RangeError("Index out of range");
  if (r < 0) throw new RangeError("Index out of range");
}

function writeFloat(e, t, r, n, f) {
  t = +t;
  r >>>= 0;
  f || checkIEEE754(e, t, r, 4, 3.4028234663852886e38, -3.4028234663852886e38);
  ieee754.write(e, t, r, n, 23, 4);
  return r + 4;
}

function writeDouble(e, t, r, n, f) {
  t = +t;
  r >>>= 0;
  f || checkIEEE754(e, t, r, 8, 1.7976931348623157e308, -1.7976931348623157e308);
  ieee754.write(e, t, r, n, 52, 8);
  return r + 8;
}

function base64clean(e) {
  if ((e = e.trim().replace(INVALID_BASE64_RE, "")).length < 2) return "";
  for (;e.length % 4 != 0; ) e += "=";
  return e;
}

function toHex(e) {
  return e < 16 ? "0" + e.toString(16) : e.toString(16);
}

function utf8ToBytes(e, t) {
  t = t || Infinity;
  for (var r, n = e.length, f = null, i = [], o = 0; o < n; ++o) {
    if ((r = e.charCodeAt(o)) > 55295 && r < 57344) {
      if (!f) {
        if (r > 56319) {
          (t -= 3) > -1 && i.push(239, 191, 189);
          continue;
        }
        if (o + 1 === n) {
          (t -= 3) > -1 && i.push(239, 191, 189);
          continue;
        }
        f = r;
        continue;
      }
      if (r < 56320) {
        (t -= 3) > -1 && i.push(239, 191, 189);
        f = r;
        continue;
      }
      r = 65536 + (f - 55296 << 10 | r - 56320);
    } else f && (t -= 3) > -1 && i.push(239, 191, 189);
    f = null;
    if (r < 128) {
      if ((t -= 1) < 0) break;
      i.push(r);
    } else if (r < 2048) {
      if ((t -= 2) < 0) break;
      i.push(r >> 6 | 192, 63 & r | 128);
    } else if (r < 65536) {
      if ((t -= 3) < 0) break;
      i.push(r >> 12 | 224, r >> 6 & 63 | 128, 63 & r | 128);
    } else {
      if (!(r < 1114112)) throw new Error("Invalid code point");
      if ((t -= 4) < 0) break;
      i.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, 63 & r | 128);
    }
  }
  return i;
}

function asciiToBytes(e) {
  for (var t = [], r = 0; r < e.length; ++r) t.push(255 & e.charCodeAt(r));
  return t;
}

function utf16leToBytes(e, t) {
  for (var r, n, f = [], i = 0; i < e.length && !((t -= 2) < 0); ++i) {
    n = (r = e.charCodeAt(i)) >> 8;
    f.push(r % 256);
    f.push(n);
  }
  return f;
}

function base64ToBytes(e) {
  return base64.toByteArray(base64clean(e));
}

function blitBuffer(e, t, r, n) {
  for (var f = 0; f < n && !(f + r >= t.length || f >= e.length); ++f) t[f + r] = e[f];
  return f;
}

function isArrayBuffer(e) {
  return e instanceof ArrayBuffer || null != e && null != e.constructor && "ArrayBuffer" === e.constructor.name && "number" == typeof e.byteLength;
}

function isArrayBufferView(e) {
  return "function" == typeof ArrayBuffer.isView && ArrayBuffer.isView(e);
}

function numberIsNaN(e) {
  return e != e;
}

var base64 = require("base64-js"), ieee754 = require("ieee754");

exports.Buffer = Buffer;

exports.SlowBuffer = SlowBuffer;

exports.INSPECT_MAX_BYTES = 50;

var K_MAX_LENGTH = 2147483647;

exports.kMaxLength = K_MAX_LENGTH;

Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

Buffer.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");

"undefined" != typeof Symbol && Symbol.species && Buffer[Symbol.species] === Buffer && Object.defineProperty(Buffer, Symbol.species, {
  value: null,
  configurable: !0,
  enumerable: !1,
  writable: !1
});

Buffer.poolSize = 8192;

Buffer.from = function(e, t, r) {
  return from(e, t, r);
};

Buffer.prototype.__proto__ = Uint8Array.prototype;

Buffer.__proto__ = Uint8Array;

Buffer.alloc = function(e, t, r) {
  return alloc(e, t, r);
};

Buffer.allocUnsafe = function(e) {
  return allocUnsafe(e);
};

Buffer.allocUnsafeSlow = function(e) {
  return allocUnsafe(e);
};

Buffer.isBuffer = function(e) {
  return null != e && !0 === e._isBuffer;
};

Buffer.compare = function(e, t) {
  if (!Buffer.isBuffer(e) || !Buffer.isBuffer(t)) throw new TypeError("Arguments must be Buffers");
  if (e === t) return 0;
  for (var r = e.length, n = t.length, f = 0, i = Math.min(r, n); f < i; ++f) if (e[f] !== t[f]) {
    r = e[f];
    n = t[f];
    break;
  }
  return r < n ? -1 : n < r ? 1 : 0;
};

Buffer.isEncoding = function(e) {
  switch (String(e).toLowerCase()) {
   case "hex":
   case "utf8":
   case "utf-8":
   case "ascii":
   case "latin1":
   case "binary":
   case "base64":
   case "ucs2":
   case "ucs-2":
   case "utf16le":
   case "utf-16le":
    return !0;

   default:
    return !1;
  }
};

Buffer.concat = function(e, t) {
  if (!Array.isArray(e)) throw new TypeError('"list" argument must be an Array of Buffers');
  if (0 === e.length) return Buffer.alloc(0);
  var r;
  if (void 0 === t) {
    t = 0;
    for (r = 0; r < e.length; ++r) t += e[r].length;
  }
  var n = Buffer.allocUnsafe(t), f = 0;
  for (r = 0; r < e.length; ++r) {
    var i = e[r];
    if (!Buffer.isBuffer(i)) throw new TypeError('"list" argument must be an Array of Buffers');
    i.copy(n, f);
    f += i.length;
  }
  return n;
};

Buffer.byteLength = byteLength;

Buffer.prototype._isBuffer = !0;

Buffer.prototype.swap16 = function() {
  var e = this.length;
  if (e % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
  for (var t = 0; t < e; t += 2) swap(this, t, t + 1);
  return this;
};

Buffer.prototype.swap32 = function() {
  var e = this.length;
  if (e % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
  for (var t = 0; t < e; t += 4) {
    swap(this, t, t + 3);
    swap(this, t + 1, t + 2);
  }
  return this;
};

Buffer.prototype.swap64 = function() {
  var e = this.length;
  if (e % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
  for (var t = 0; t < e; t += 8) {
    swap(this, t, t + 7);
    swap(this, t + 1, t + 6);
    swap(this, t + 2, t + 5);
    swap(this, t + 3, t + 4);
  }
  return this;
};

Buffer.prototype.toString = function() {
  var e = this.length;
  return 0 === e ? "" : 0 === arguments.length ? utf8Slice(this, 0, e) : slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function(e) {
  if (!Buffer.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
  return this === e || 0 === Buffer.compare(this, e);
};

Buffer.prototype.inspect = function() {
  var e = "", t = exports.INSPECT_MAX_BYTES;
  if (this.length > 0) {
    e = this.toString("hex", 0, t).match(/.{2}/g).join(" ");
    this.length > t && (e += " ... ");
  }
  return "<Buffer " + e + ">";
};

Buffer.prototype.compare = function(e, t, r, n, f) {
  if (!Buffer.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
  void 0 === t && (t = 0);
  void 0 === r && (r = e ? e.length : 0);
  void 0 === n && (n = 0);
  void 0 === f && (f = this.length);
  if (t < 0 || r > e.length || n < 0 || f > this.length) throw new RangeError("out of range index");
  if (n >= f && t >= r) return 0;
  if (n >= f) return -1;
  if (t >= r) return 1;
  t >>>= 0;
  r >>>= 0;
  n >>>= 0;
  f >>>= 0;
  if (this === e) return 0;
  for (var i = f - n, o = r - t, u = Math.min(i, o), s = this.slice(n, f), a = e.slice(t, r), h = 0; h < u; ++h) if (s[h] !== a[h]) {
    i = s[h];
    o = a[h];
    break;
  }
  return i < o ? -1 : o < i ? 1 : 0;
};

Buffer.prototype.includes = function(e, t, r) {
  return -1 !== this.indexOf(e, t, r);
};

Buffer.prototype.indexOf = function(e, t, r) {
  return bidirectionalIndexOf(this, e, t, r, !0);
};

Buffer.prototype.lastIndexOf = function(e, t, r) {
  return bidirectionalIndexOf(this, e, t, r, !1);
};

Buffer.prototype.write = function(e, t, r, n) {
  if (void 0 === t) {
    n = "utf8";
    r = this.length;
    t = 0;
  } else if (void 0 === r && "string" == typeof t) {
    n = t;
    r = this.length;
    t = 0;
  } else {
    if (!isFinite(t)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    t >>>= 0;
    if (isFinite(r)) {
      r >>>= 0;
      void 0 === n && (n = "utf8");
    } else {
      n = r;
      r = void 0;
    }
  }
  var f = this.length - t;
  (void 0 === r || r > f) && (r = f);
  if (e.length > 0 && (r < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds");
  n || (n = "utf8");
  for (var i = !1; ;) switch (n) {
   case "hex":
    return hexWrite(this, e, t, r);

   case "utf8":
   case "utf-8":
    return utf8Write(this, e, t, r);

   case "ascii":
    return asciiWrite(this, e, t, r);

   case "latin1":
   case "binary":
    return latin1Write(this, e, t, r);

   case "base64":
    return base64Write(this, e, t, r);

   case "ucs2":
   case "ucs-2":
   case "utf16le":
   case "utf-16le":
    return ucs2Write(this, e, t, r);

   default:
    if (i) throw new TypeError("Unknown encoding: " + n);
    n = ("" + n).toLowerCase();
    i = !0;
  }
};

Buffer.prototype.toJSON = function() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

var MAX_ARGUMENTS_LENGTH = 4096;

Buffer.prototype.slice = function(e, t) {
  var r = this.length;
  e = ~~e;
  t = void 0 === t ? r : ~~t;
  e < 0 ? (e += r) < 0 && (e = 0) : e > r && (e = r);
  t < 0 ? (t += r) < 0 && (t = 0) : t > r && (t = r);
  t < e && (t = e);
  var n = this.subarray(e, t);
  n.__proto__ = Buffer.prototype;
  return n;
};

Buffer.prototype.readUIntLE = function(e, t, r) {
  e >>>= 0;
  t >>>= 0;
  r || checkOffset(e, t, this.length);
  for (var n = this[e], f = 1, i = 0; ++i < t && (f *= 256); ) n += this[e + i] * f;
  return n;
};

Buffer.prototype.readUIntBE = function(e, t, r) {
  e >>>= 0;
  t >>>= 0;
  r || checkOffset(e, t, this.length);
  for (var n = this[e + --t], f = 1; t > 0 && (f *= 256); ) n += this[e + --t] * f;
  return n;
};

Buffer.prototype.readUInt8 = function(e, t) {
  e >>>= 0;
  t || checkOffset(e, 1, this.length);
  return this[e];
};

Buffer.prototype.readUInt16LE = function(e, t) {
  e >>>= 0;
  t || checkOffset(e, 2, this.length);
  return this[e] | this[e + 1] << 8;
};

Buffer.prototype.readUInt16BE = function(e, t) {
  e >>>= 0;
  t || checkOffset(e, 2, this.length);
  return this[e] << 8 | this[e + 1];
};

Buffer.prototype.readUInt32LE = function(e, t) {
  e >>>= 0;
  t || checkOffset(e, 4, this.length);
  return (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3];
};

Buffer.prototype.readUInt32BE = function(e, t) {
  e >>>= 0;
  t || checkOffset(e, 4, this.length);
  return 16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
};

Buffer.prototype.readIntLE = function(e, t, r) {
  e >>>= 0;
  t >>>= 0;
  r || checkOffset(e, t, this.length);
  for (var n = this[e], f = 1, i = 0; ++i < t && (f *= 256); ) n += this[e + i] * f;
  n >= (f *= 128) && (n -= Math.pow(2, 8 * t));
  return n;
};

Buffer.prototype.readIntBE = function(e, t, r) {
  e >>>= 0;
  t >>>= 0;
  r || checkOffset(e, t, this.length);
  for (var n = t, f = 1, i = this[e + --n]; n > 0 && (f *= 256); ) i += this[e + --n] * f;
  i >= (f *= 128) && (i -= Math.pow(2, 8 * t));
  return i;
};

Buffer.prototype.readInt8 = function(e, t) {
  e >>>= 0;
  t || checkOffset(e, 1, this.length);
  return 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e];
};

Buffer.prototype.readInt16LE = function(e, t) {
  e >>>= 0;
  t || checkOffset(e, 2, this.length);
  var r = this[e] | this[e + 1] << 8;
  return 32768 & r ? 4294901760 | r : r;
};

Buffer.prototype.readInt16BE = function(e, t) {
  e >>>= 0;
  t || checkOffset(e, 2, this.length);
  var r = this[e + 1] | this[e] << 8;
  return 32768 & r ? 4294901760 | r : r;
};

Buffer.prototype.readInt32LE = function(e, t) {
  e >>>= 0;
  t || checkOffset(e, 4, this.length);
  return this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
};

Buffer.prototype.readInt32BE = function(e, t) {
  e >>>= 0;
  t || checkOffset(e, 4, this.length);
  return this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
};

Buffer.prototype.readFloatLE = function(e, t) {
  e >>>= 0;
  t || checkOffset(e, 4, this.length);
  return ieee754.read(this, e, !0, 23, 4);
};

Buffer.prototype.readFloatBE = function(e, t) {
  e >>>= 0;
  t || checkOffset(e, 4, this.length);
  return ieee754.read(this, e, !1, 23, 4);
};

Buffer.prototype.readDoubleLE = function(e, t) {
  e >>>= 0;
  t || checkOffset(e, 8, this.length);
  return ieee754.read(this, e, !0, 52, 8);
};

Buffer.prototype.readDoubleBE = function(e, t) {
  e >>>= 0;
  t || checkOffset(e, 8, this.length);
  return ieee754.read(this, e, !1, 52, 8);
};

Buffer.prototype.writeUIntLE = function(e, t, r, n) {
  e = +e;
  t >>>= 0;
  r >>>= 0;
  n || checkInt(this, e, t, r, Math.pow(2, 8 * r) - 1, 0);
  var f = 1, i = 0;
  this[t] = 255 & e;
  for (;++i < r && (f *= 256); ) this[t + i] = e / f & 255;
  return t + r;
};

Buffer.prototype.writeUIntBE = function(e, t, r, n) {
  e = +e;
  t >>>= 0;
  r >>>= 0;
  n || checkInt(this, e, t, r, Math.pow(2, 8 * r) - 1, 0);
  var f = r - 1, i = 1;
  this[t + f] = 255 & e;
  for (;--f >= 0 && (i *= 256); ) this[t + f] = e / i & 255;
  return t + r;
};

Buffer.prototype.writeUInt8 = function(e, t, r) {
  e = +e;
  t >>>= 0;
  r || checkInt(this, e, t, 1, 255, 0);
  this[t] = 255 & e;
  return t + 1;
};

Buffer.prototype.writeUInt16LE = function(e, t, r) {
  e = +e;
  t >>>= 0;
  r || checkInt(this, e, t, 2, 65535, 0);
  this[t] = 255 & e;
  this[t + 1] = e >>> 8;
  return t + 2;
};

Buffer.prototype.writeUInt16BE = function(e, t, r) {
  e = +e;
  t >>>= 0;
  r || checkInt(this, e, t, 2, 65535, 0);
  this[t] = e >>> 8;
  this[t + 1] = 255 & e;
  return t + 2;
};

Buffer.prototype.writeUInt32LE = function(e, t, r) {
  e = +e;
  t >>>= 0;
  r || checkInt(this, e, t, 4, 4294967295, 0);
  this[t + 3] = e >>> 24;
  this[t + 2] = e >>> 16;
  this[t + 1] = e >>> 8;
  this[t] = 255 & e;
  return t + 4;
};

Buffer.prototype.writeUInt32BE = function(e, t, r) {
  e = +e;
  t >>>= 0;
  r || checkInt(this, e, t, 4, 4294967295, 0);
  this[t] = e >>> 24;
  this[t + 1] = e >>> 16;
  this[t + 2] = e >>> 8;
  this[t + 3] = 255 & e;
  return t + 4;
};

Buffer.prototype.writeIntLE = function(e, t, r, n) {
  e = +e;
  t >>>= 0;
  if (!n) {
    var f = Math.pow(2, 8 * r - 1);
    checkInt(this, e, t, r, f - 1, -f);
  }
  var i = 0, o = 1, u = 0;
  this[t] = 255 & e;
  for (;++i < r && (o *= 256); ) {
    e < 0 && 0 === u && 0 !== this[t + i - 1] && (u = 1);
    this[t + i] = (e / o >> 0) - u & 255;
  }
  return t + r;
};

Buffer.prototype.writeIntBE = function(e, t, r, n) {
  e = +e;
  t >>>= 0;
  if (!n) {
    var f = Math.pow(2, 8 * r - 1);
    checkInt(this, e, t, r, f - 1, -f);
  }
  var i = r - 1, o = 1, u = 0;
  this[t + i] = 255 & e;
  for (;--i >= 0 && (o *= 256); ) {
    e < 0 && 0 === u && 0 !== this[t + i + 1] && (u = 1);
    this[t + i] = (e / o >> 0) - u & 255;
  }
  return t + r;
};

Buffer.prototype.writeInt8 = function(e, t, r) {
  e = +e;
  t >>>= 0;
  r || checkInt(this, e, t, 1, 127, -128);
  e < 0 && (e = 255 + e + 1);
  this[t] = 255 & e;
  return t + 1;
};

Buffer.prototype.writeInt16LE = function(e, t, r) {
  e = +e;
  t >>>= 0;
  r || checkInt(this, e, t, 2, 32767, -32768);
  this[t] = 255 & e;
  this[t + 1] = e >>> 8;
  return t + 2;
};

Buffer.prototype.writeInt16BE = function(e, t, r) {
  e = +e;
  t >>>= 0;
  r || checkInt(this, e, t, 2, 32767, -32768);
  this[t] = e >>> 8;
  this[t + 1] = 255 & e;
  return t + 2;
};

Buffer.prototype.writeInt32LE = function(e, t, r) {
  e = +e;
  t >>>= 0;
  r || checkInt(this, e, t, 4, 2147483647, -2147483648);
  this[t] = 255 & e;
  this[t + 1] = e >>> 8;
  this[t + 2] = e >>> 16;
  this[t + 3] = e >>> 24;
  return t + 4;
};

Buffer.prototype.writeInt32BE = function(e, t, r) {
  e = +e;
  t >>>= 0;
  r || checkInt(this, e, t, 4, 2147483647, -2147483648);
  e < 0 && (e = 4294967295 + e + 1);
  this[t] = e >>> 24;
  this[t + 1] = e >>> 16;
  this[t + 2] = e >>> 8;
  this[t + 3] = 255 & e;
  return t + 4;
};

Buffer.prototype.writeFloatLE = function(e, t, r) {
  return writeFloat(this, e, t, !0, r);
};

Buffer.prototype.writeFloatBE = function(e, t, r) {
  return writeFloat(this, e, t, !1, r);
};

Buffer.prototype.writeDoubleLE = function(e, t, r) {
  return writeDouble(this, e, t, !0, r);
};

Buffer.prototype.writeDoubleBE = function(e, t, r) {
  return writeDouble(this, e, t, !1, r);
};

Buffer.prototype.copy = function(e, t, r, n) {
  r || (r = 0);
  n || 0 === n || (n = this.length);
  t >= e.length && (t = e.length);
  t || (t = 0);
  n > 0 && n < r && (n = r);
  if (n === r) return 0;
  if (0 === e.length || 0 === this.length) return 0;
  if (t < 0) throw new RangeError("targetStart out of bounds");
  if (r < 0 || r >= this.length) throw new RangeError("sourceStart out of bounds");
  if (n < 0) throw new RangeError("sourceEnd out of bounds");
  n > this.length && (n = this.length);
  e.length - t < n - r && (n = e.length - t + r);
  var f, i = n - r;
  if (this === e && r < t && t < n) for (f = i - 1; f >= 0; --f) e[f + t] = this[f + r]; else if (i < 1e3) for (f = 0; f < i; ++f) e[f + t] = this[f + r]; else Uint8Array.prototype.set.call(e, this.subarray(r, r + i), t);
  return i;
};

Buffer.prototype.fill = function(e, t, r, n) {
  if ("string" == typeof e) {
    if ("string" == typeof t) {
      n = t;
      t = 0;
      r = this.length;
    } else if ("string" == typeof r) {
      n = r;
      r = this.length;
    }
    if (1 === e.length) {
      var f = e.charCodeAt(0);
      f < 256 && (e = f);
    }
    if (void 0 !== n && "string" != typeof n) throw new TypeError("encoding must be a string");
    if ("string" == typeof n && !Buffer.isEncoding(n)) throw new TypeError("Unknown encoding: " + n);
  } else "number" == typeof e && (e &= 255);
  if (t < 0 || this.length < t || this.length < r) throw new RangeError("Out of range index");
  if (r <= t) return this;
  t >>>= 0;
  r = void 0 === r ? this.length : r >>> 0;
  e || (e = 0);
  var i;
  if ("number" == typeof e) for (i = t; i < r; ++i) this[i] = e; else {
    var o = Buffer.isBuffer(e) ? e : new Buffer(e, n), u = o.length;
    for (i = 0; i < r - t; ++i) this[i + t] = o[i % u];
  }
  return this;
};

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
},{"base64-js":4,"ieee754":9}],7:[function(require,module,exports){
var once = require("once"), noop = function() {}, isRequest = function(e) {
  return e.setHeader && "function" == typeof e.abort;
}, isChildProcess = function(e) {
  return e.stdio && Array.isArray(e.stdio) && 3 === e.stdio.length;
}, eos = function(e, r, n) {
  if ("function" == typeof r) return eos(e, null, r);
  r || (r = {});
  n = once(n || noop);
  var o = e._writableState, t = e._readableState, i = r.readable || !1 !== r.readable && e.readable, s = r.writable || !1 !== r.writable && e.writable, l = function() {
    e.writable || c();
  }, c = function() {
    s = !1;
    i || n.call(e);
  }, a = function() {
    i = !1;
    s || n.call(e);
  }, u = function(r) {
    n.call(e, r ? new Error("exited with error code: " + r) : null);
  }, d = function() {
    return (!i || t && t.ended) && (!s || o && o.ended) ? void 0 : n.call(e, new Error("premature close"));
  }, f = function() {
    e.req.on("finish", c);
  };
  if (isRequest(e)) {
    e.on("complete", c);
    e.on("abort", d);
    e.req ? f() : e.on("request", f);
  } else if (s && !o) {
    e.on("end", l);
    e.on("close", l);
  }
  isChildProcess(e) && e.on("exit", u);
  e.on("end", a);
  e.on("finish", c);
  !1 !== r.error && e.on("error", n);
  e.on("close", d);
  return function() {
    e.removeListener("complete", c);
    e.removeListener("abort", d);
    e.removeListener("request", f);
    e.req && e.req.removeListener("finish", c);
    e.removeListener("end", l);
    e.removeListener("close", l);
    e.removeListener("finish", c);
    e.removeListener("exit", u);
    e.removeListener("end", a);
    e.removeListener("error", n);
    e.removeListener("close", d);
  };
};

module.exports = eos;
},{"once":18}],8:[function(require,module,exports){
function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || void 0;
}

function isFunction(e) {
  return "function" == typeof e;
}

function isNumber(e) {
  return "number" == typeof e;
}

function isObject(e) {
  return "object" == typeof e && null !== e;
}

function isUndefined(e) {
  return void 0 === e;
}

module.exports = EventEmitter;

EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = void 0;

EventEmitter.prototype._maxListeners = void 0;

EventEmitter.defaultMaxListeners = 10;

EventEmitter.prototype.setMaxListeners = function(e) {
  if (!isNumber(e) || e < 0 || isNaN(e)) throw TypeError("n must be a positive number");
  this._maxListeners = e;
  return this;
};

EventEmitter.prototype.emit = function(e) {
  var t, i, n, s, r, o;
  this._events || (this._events = {});
  if ("error" === e && (!this._events.error || isObject(this._events.error) && !this._events.error.length)) {
    if ((t = arguments[1]) instanceof Error) throw t;
    var h = new Error('Uncaught, unspecified "error" event. (' + t + ")");
    h.context = t;
    throw h;
  }
  if (isUndefined(i = this._events[e])) return !1;
  if (isFunction(i)) switch (arguments.length) {
   case 1:
    i.call(this);
    break;

   case 2:
    i.call(this, arguments[1]);
    break;

   case 3:
    i.call(this, arguments[1], arguments[2]);
    break;

   default:
    s = Array.prototype.slice.call(arguments, 1);
    i.apply(this, s);
  } else if (isObject(i)) {
    s = Array.prototype.slice.call(arguments, 1);
    n = (o = i.slice()).length;
    for (r = 0; r < n; r++) o[r].apply(this, s);
  }
  return !0;
};

EventEmitter.prototype.addListener = function(e, t) {
  var i;
  if (!isFunction(t)) throw TypeError("listener must be a function");
  this._events || (this._events = {});
  this._events.newListener && this.emit("newListener", e, isFunction(t.listener) ? t.listener : t);
  this._events[e] ? isObject(this._events[e]) ? this._events[e].push(t) : this._events[e] = [ this._events[e], t ] : this._events[e] = t;
  if (isObject(this._events[e]) && !this._events[e].warned && (i = isUndefined(this._maxListeners) ? EventEmitter.defaultMaxListeners : this._maxListeners) && i > 0 && this._events[e].length > i) {
    this._events[e].warned = !0;
    console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", this._events[e].length);
    "function" == typeof console.trace && console.trace();
  }
  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(e, t) {
  function g() {
    this.removeListener(e, g);
    if (!i) {
      i = !0;
      t.apply(this, arguments);
    }
  }
  if (!isFunction(t)) throw TypeError("listener must be a function");
  var i = !1;
  g.listener = t;
  this.on(e, g);
  return this;
};

EventEmitter.prototype.removeListener = function(e, t) {
  var i, n, s, r;
  if (!isFunction(t)) throw TypeError("listener must be a function");
  if (!this._events || !this._events[e]) return this;
  s = (i = this._events[e]).length;
  n = -1;
  if (i === t || isFunction(i.listener) && i.listener === t) {
    delete this._events[e];
    this._events.removeListener && this.emit("removeListener", e, t);
  } else if (isObject(i)) {
    for (r = s; r-- > 0; ) if (i[r] === t || i[r].listener && i[r].listener === t) {
      n = r;
      break;
    }
    if (n < 0) return this;
    if (1 === i.length) {
      i.length = 0;
      delete this._events[e];
    } else i.splice(n, 1);
    this._events.removeListener && this.emit("removeListener", e, t);
  }
  return this;
};

EventEmitter.prototype.removeAllListeners = function(e) {
  var t, i;
  if (!this._events) return this;
  if (!this._events.removeListener) {
    0 === arguments.length ? this._events = {} : this._events[e] && delete this._events[e];
    return this;
  }
  if (0 === arguments.length) {
    for (t in this._events) "removeListener" !== t && this.removeAllListeners(t);
    this.removeAllListeners("removeListener");
    this._events = {};
    return this;
  }
  if (isFunction(i = this._events[e])) this.removeListener(e, i); else if (i) for (;i.length; ) this.removeListener(e, i[i.length - 1]);
  delete this._events[e];
  return this;
};

EventEmitter.prototype.listeners = function(e) {
  return this._events && this._events[e] ? isFunction(this._events[e]) ? [ this._events[e] ] : this._events[e].slice() : [];
};

EventEmitter.prototype.listenerCount = function(e) {
  if (this._events) {
    var t = this._events[e];
    if (isFunction(t)) return 1;
    if (t) return t.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(e, t) {
  return e.listenerCount(t);
};
},{}],9:[function(require,module,exports){
exports.read = function(t, a, o, f, i) {
  var r, e, h = 8 * i - f - 1, M = (1 << h) - 1, p = M >> 1, n = -7, w = o ? i - 1 : 0, s = o ? -1 : 1, N = t[a + w];
  w += s;
  r = N & (1 << -n) - 1;
  N >>= -n;
  n += h;
  for (;n > 0; r = 256 * r + t[a + w], w += s, n -= 8) ;
  e = r & (1 << -n) - 1;
  r >>= -n;
  n += f;
  for (;n > 0; e = 256 * e + t[a + w], w += s, n -= 8) ;
  if (0 === r) r = 1 - p; else {
    if (r === M) return e ? NaN : Infinity * (N ? -1 : 1);
    e += Math.pow(2, f);
    r -= p;
  }
  return (N ? -1 : 1) * e * Math.pow(2, r - f);
};

exports.write = function(t, a, o, f, i, r) {
  var e, h, M, p = 8 * r - i - 1, n = (1 << p) - 1, w = n >> 1, s = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, N = f ? 0 : r - 1, l = f ? 1 : -1, u = a < 0 || 0 === a && 1 / a < 0 ? 1 : 0;
  a = Math.abs(a);
  if (isNaN(a) || Infinity === a) {
    h = isNaN(a) ? 1 : 0;
    e = n;
  } else {
    e = Math.floor(Math.log(a) / Math.LN2);
    if (a * (M = Math.pow(2, -e)) < 1) {
      e--;
      M *= 2;
    }
    if ((a += e + w >= 1 ? s / M : s * Math.pow(2, 1 - w)) * M >= 2) {
      e++;
      M /= 2;
    }
    if (e + w >= n) {
      h = 0;
      e = n;
    } else if (e + w >= 1) {
      h = (a * M - 1) * Math.pow(2, i);
      e += w;
    } else {
      h = a * Math.pow(2, w - 1) * Math.pow(2, i);
      e = 0;
    }
  }
  for (;i >= 8; t[o + N] = 255 & h, N += l, h /= 256, i -= 8) ;
  e = e << i | h;
  p += i;
  for (;p > 0; t[o + N] = 255 & e, N += l, e /= 256, p -= 8) ;
  t[o + N - l] |= 128 * u;
};
},{}],10:[function(require,module,exports){
function MediaElementWrapper(e, r) {
  var t = this;
  if (!(t instanceof MediaElementWrapper)) return new MediaElementWrapper(e, r);
  if (!MediaSource) throw new Error("web browser lacks MediaSource support");
  r || (r = {});
  t._bufferDuration = r.bufferDuration || DEFAULT_BUFFER_DURATION;
  t._elem = e;
  t._mediaSource = new MediaSource();
  t._streams = [];
  t.detailedError = null;
  t._errorHandler = function() {
    t._elem.removeEventListener("error", t._errorHandler);
    t._streams.slice().forEach(function(e) {
      e.destroy(t._elem.error);
    });
  };
  t._elem.addEventListener("error", t._errorHandler);
  t._elem.src = window.URL.createObjectURL(t._mediaSource);
}

function MediaSourceStream(e, r) {
  var t = this;
  stream.Writable.call(t);
  t._wrapper = e;
  t._elem = e._elem;
  t._mediaSource = e._mediaSource;
  t._allStreams = e._streams;
  t._allStreams.push(t);
  t._bufferDuration = e._bufferDuration;
  t._sourceBuffer = null;
  t._openHandler = function() {
    t._onSourceOpen();
  };
  t._flowHandler = function() {
    t._flow();
  };
  if ("string" == typeof r) {
    t._type = r;
    "open" === t._mediaSource.readyState ? t._createSourceBuffer() : t._mediaSource.addEventListener("sourceopen", t._openHandler);
  } else if (null === r._sourceBuffer) {
    r.destroy();
    t._type = r._type;
    t._mediaSource.addEventListener("sourceopen", t._openHandler);
  } else {
    if (!r._sourceBuffer) throw new Error("The argument to MediaElementWrapper.createWriteStream must be a string or a previous stream returned from that function");
    r.destroy();
    t._type = r._type;
    t._sourceBuffer = r._sourceBuffer;
    t._sourceBuffer.addEventListener("updateend", t._flowHandler);
  }
  t._elem.addEventListener("timeupdate", t._flowHandler);
  t.on("error", function(e) {
    t._wrapper.error(e);
  });
  t.on("finish", function() {
    if (!t.destroyed) {
      t._finished = !0;
      if (t._allStreams.every(function(e) {
        return e._finished;
      })) try {
        t._mediaSource.endOfStream();
      } catch (e) {}
    }
  });
}

module.exports = MediaElementWrapper;

var inherits = require("/bundle/utils").inherit, stream = require("readable-stream"), toArrayBuffer = require("to-arraybuffer"), MediaSource = "undefined" != typeof window && window.MediaSource, DEFAULT_BUFFER_DURATION = 60;

MediaElementWrapper.prototype.createWriteStream = function(e) {
  return new MediaSourceStream(this, e);
};

MediaElementWrapper.prototype.error = function(e) {
  this.detailedError || (this.detailedError = e);
  try {
    this._mediaSource.endOfStream("decode");
  } catch (e) {}
};

inherits(MediaSourceStream, stream.Writable);

MediaSourceStream.prototype._onSourceOpen = function() {
  if (!this.destroyed) {
    this._mediaSource.removeEventListener("sourceopen", this._openHandler);
    this._createSourceBuffer();
  }
};

MediaSourceStream.prototype.destroy = function(e) {
  if (!this.destroyed) {
    this.destroyed = !0;
    this._allStreams.splice(this._allStreams.indexOf(this), 1);
    this._mediaSource.removeEventListener("sourceopen", this._openHandler);
    this._elem.removeEventListener("timeupdate", this._flowHandler);
    if (this._sourceBuffer) {
      this._sourceBuffer.removeEventListener("updateend", this._flowHandler);
      "open" === this._mediaSource.readyState && this._sourceBuffer.abort();
    }
    e && this.emit("error", e);
    this.emit("close");
  }
};

MediaSourceStream.prototype._createSourceBuffer = function() {
  if (!this.destroyed) if (MediaSource.isTypeSupported(this._type)) {
    this._sourceBuffer = this._mediaSource.addSourceBuffer(this._type);
    this._sourceBuffer.addEventListener("updateend", this._flowHandler);
    if (this._cb) {
      var e = this._cb;
      this._cb = null;
      e();
    }
  } else this.destroy(new Error("The provided type is not supported"));
};

MediaSourceStream.prototype._write = function(e, r, t) {
  var i = this;
  if (!i.destroyed) if (i._sourceBuffer) {
    if (i._sourceBuffer.updating) return t(new Error("Cannot append buffer while source buffer updating"));
    try {
      i._sourceBuffer.appendBuffer(toArrayBuffer(e));
    } catch (e) {
      i.destroy(e);
      return;
    }
    i._cb = t;
  } else i._cb = function(o) {
    if (o) return t(o);
    i._write(e, r, t);
  };
};

MediaSourceStream.prototype._flow = function() {
  if (!this.destroyed && this._sourceBuffer && !this._sourceBuffer.updating && !("open" === this._mediaSource.readyState && this._getBufferDuration() > this._bufferDuration) && this._cb) {
    var e = this._cb;
    this._cb = null;
    e();
  }
};

var EPSILON = 0;

MediaSourceStream.prototype._getBufferDuration = function() {
  for (var e = this._sourceBuffer.buffered, r = this._elem.currentTime, t = -1, i = 0; i < e.length; i++) {
    var o = e.start(i), a = e.end(i) + EPSILON;
    if (o > r) break;
    (t >= 0 || r <= a) && (t = a);
  }
  var n = t - r;
  n < 0 && (n = 0);
  return n;
};
},{"/bundle/utils":2,"readable-stream":29,"to-arraybuffer":31}],11:[function(require,module,exports){
(function (Buffer){
function writeReserved(e, t, r) {
  for (var n = t; n < r; n++) e[n] = 0;
}

function writeDate(e, t, r) {
  t.writeUInt32BE(Math.floor((e.getTime() + TIME_OFFSET) / 1e3), r);
}

function writeFixed32(e, t, r) {
  t.writeUInt16BE(Math.floor(e) % 65536, r);
  t.writeUInt16BE(Math.floor(256 * e * 256) % 65536, r + 2);
}

function writeFixed16(e, t, r) {
  t[r] = Math.floor(e) % 256;
  t[r + 1] = Math.floor(256 * e) % 256;
}

function writeMatrix(e, t, r) {
  e || (e = [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ]);
  for (var n = 0; n < e.length; n++) writeFixed32(e[n], t, r + 4 * n);
}

function writeString(e, t, r) {
  var n = new Buffer(e, "utf8");
  n.copy(t, r);
  t[r + n.length] = 0;
}

function readMatrix(e) {
  for (var t = new Array(e.length / 4), r = 0; r < t.length; r++) t[r] = readFixed32(e, 4 * r);
  return t;
}

function readDate(e, t) {
  return new Date(1e3 * e.readUInt32BE(t) - TIME_OFFSET);
}

function readFixed32(e, t) {
  return e.readUInt16BE(t) + e.readUInt16BE(t + 2) / 65536;
}

function readFixed16(e, t) {
  return e[t] + e[t + 1] / 256;
}

function readString(e, t, r) {
  var n;
  for (n = 0; n < r && 0 !== e[t + n]; n++) ;
  return e.toString("utf8", t, t + n);
}

var Box = require("./index"), Descriptor = require("./descriptor"), TIME_OFFSET = 20828448e5;

exports.fullBoxes = {};

var fullBoxes = [ "mvhd", "tkhd", "mdhd", "vmhd", "smhd", "stsd", "esds", "stsz", "stco", "stss", "stts", "ctts", "stsc", "dref", "elst", "hdlr", "mehd", "trex", "mfhd", "tfhd", "tfdt", "trun" ];

fullBoxes.forEach(function(e) {
  exports.fullBoxes[e] = !0;
});

exports.ftyp = {};

exports.ftyp.encode = function(e, t, r) {
  t = t ? t.slice(r) : new Buffer(exports.ftyp.encodingLength(e));
  var n = e.compatibleBrands || [];
  t.write(e.brand, 0, 4, "ascii");
  t.writeUInt32BE(e.brandVersion, 4);
  for (var o = 0; o < n.length; o++) t.write(n[o], 8 + 4 * o, 4, "ascii");
  exports.ftyp.encode.bytes = 8 + 4 * n.length;
  return t;
};

exports.ftyp.decode = function(e, t) {
  for (var r = (e = e.slice(t)).toString("ascii", 0, 4), n = e.readUInt32BE(4), o = [], i = 8; i < e.length; i += 4) o.push(e.toString("ascii", i, i + 4));
  return {
    brand: r,
    brandVersion: n,
    compatibleBrands: o
  };
};

exports.ftyp.encodingLength = function(e) {
  return 8 + 4 * (e.compatibleBrands || []).length;
};

exports.mvhd = {};

exports.mvhd.encode = function(e, t, r) {
  t = t ? t.slice(r) : new Buffer(96);
  writeDate(e.ctime || new Date(), t, 0);
  writeDate(e.mtime || new Date(), t, 4);
  t.writeUInt32BE(e.timeScale || 0, 8);
  t.writeUInt32BE(e.duration || 0, 12);
  writeFixed32(e.preferredRate || 0, t, 16);
  writeFixed16(e.preferredVolume || 0, t, 20);
  writeReserved(t, 22, 32);
  writeMatrix(e.matrix, t, 32);
  t.writeUInt32BE(e.previewTime || 0, 68);
  t.writeUInt32BE(e.previewDuration || 0, 72);
  t.writeUInt32BE(e.posterTime || 0, 76);
  t.writeUInt32BE(e.selectionTime || 0, 80);
  t.writeUInt32BE(e.selectionDuration || 0, 84);
  t.writeUInt32BE(e.currentTime || 0, 88);
  t.writeUInt32BE(e.nextTrackId || 0, 92);
  exports.mvhd.encode.bytes = 96;
  return t;
};

exports.mvhd.decode = function(e, t) {
  return {
    ctime: readDate(e = e.slice(t), 0),
    mtime: readDate(e, 4),
    timeScale: e.readUInt32BE(8),
    duration: e.readUInt32BE(12),
    preferredRate: readFixed32(e, 16),
    preferredVolume: readFixed16(e, 20),
    matrix: readMatrix(e.slice(32, 68)),
    previewTime: e.readUInt32BE(68),
    previewDuration: e.readUInt32BE(72),
    posterTime: e.readUInt32BE(76),
    selectionTime: e.readUInt32BE(80),
    selectionDuration: e.readUInt32BE(84),
    currentTime: e.readUInt32BE(88),
    nextTrackId: e.readUInt32BE(92)
  };
};

exports.mvhd.encodingLength = function(e) {
  return 96;
};

exports.tkhd = {};

exports.tkhd.encode = function(e, t, r) {
  t = t ? t.slice(r) : new Buffer(80);
  writeDate(e.ctime || new Date(), t, 0);
  writeDate(e.mtime || new Date(), t, 4);
  t.writeUInt32BE(e.trackId || 0, 8);
  writeReserved(t, 12, 16);
  t.writeUInt32BE(e.duration || 0, 16);
  writeReserved(t, 20, 28);
  t.writeUInt16BE(e.layer || 0, 28);
  t.writeUInt16BE(e.alternateGroup || 0, 30);
  t.writeUInt16BE(e.volume || 0, 32);
  writeMatrix(e.matrix, t, 36);
  t.writeUInt32BE(e.trackWidth || 0, 72);
  t.writeUInt32BE(e.trackHeight || 0, 76);
  exports.tkhd.encode.bytes = 80;
  return t;
};

exports.tkhd.decode = function(e, t) {
  return {
    ctime: readDate(e = e.slice(t), 0),
    mtime: readDate(e, 4),
    trackId: e.readUInt32BE(8),
    duration: e.readUInt32BE(16),
    layer: e.readUInt16BE(28),
    alternateGroup: e.readUInt16BE(30),
    volume: e.readUInt16BE(32),
    matrix: readMatrix(e.slice(36, 72)),
    trackWidth: e.readUInt32BE(72),
    trackHeight: e.readUInt32BE(76)
  };
};

exports.tkhd.encodingLength = function(e) {
  return 80;
};

exports.mdhd = {};

exports.mdhd.encode = function(e, t, r) {
  t = t ? t.slice(r) : new Buffer(20);
  writeDate(e.ctime || new Date(), t, 0);
  writeDate(e.mtime || new Date(), t, 4);
  t.writeUInt32BE(e.timeScale || 0, 8);
  t.writeUInt32BE(e.duration || 0, 12);
  t.writeUInt16BE(e.language || 0, 16);
  t.writeUInt16BE(e.quality || 0, 18);
  exports.mdhd.encode.bytes = 20;
  return t;
};

exports.mdhd.decode = function(e, t) {
  return {
    ctime: readDate(e = e.slice(t), 0),
    mtime: readDate(e, 4),
    timeScale: e.readUInt32BE(8),
    duration: e.readUInt32BE(12),
    language: e.readUInt16BE(16),
    quality: e.readUInt16BE(18)
  };
};

exports.mdhd.encodingLength = function(e) {
  return 20;
};

exports.vmhd = {};

exports.vmhd.encode = function(e, t, r) {
  (t = t ? t.slice(r) : new Buffer(8)).writeUInt16BE(e.graphicsMode || 0, 0);
  var n = e.opcolor || [ 0, 0, 0 ];
  t.writeUInt16BE(n[0], 2);
  t.writeUInt16BE(n[1], 4);
  t.writeUInt16BE(n[2], 6);
  exports.vmhd.encode.bytes = 8;
  return t;
};

exports.vmhd.decode = function(e, t) {
  return {
    graphicsMode: (e = e.slice(t)).readUInt16BE(0),
    opcolor: [ e.readUInt16BE(2), e.readUInt16BE(4), e.readUInt16BE(6) ]
  };
};

exports.vmhd.encodingLength = function(e) {
  return 8;
};

exports.smhd = {};

exports.smhd.encode = function(e, t, r) {
  (t = t ? t.slice(r) : new Buffer(4)).writeUInt16BE(e.balance || 0, 0);
  writeReserved(t, 2, 4);
  exports.smhd.encode.bytes = 4;
  return t;
};

exports.smhd.decode = function(e, t) {
  return {
    balance: (e = e.slice(t)).readUInt16BE(0)
  };
};

exports.smhd.encodingLength = function(e) {
  return 4;
};

exports.stsd = {};

exports.stsd.encode = function(e, t, r) {
  t = t ? t.slice(r) : new Buffer(exports.stsd.encodingLength(e));
  var n = e.entries || [];
  t.writeUInt32BE(n.length, 0);
  for (var o = 4, i = 0; i < n.length; i++) {
    Box.encode(n[i], t, o);
    o += Box.encode.bytes;
  }
  exports.stsd.encode.bytes = o;
  return t;
};

exports.stsd.decode = function(e, t, r) {
  for (var n = (e = e.slice(t)).readUInt32BE(0), o = new Array(n), i = 4, s = 0; s < n; s++) {
    var d = Box.decode(e, i, r);
    o[s] = d;
    i += d.length;
  }
  return {
    entries: o
  };
};

exports.stsd.encodingLength = function(e) {
  var t = 4;
  if (!e.entries) return t;
  for (var r = 0; r < e.entries.length; r++) t += Box.encodingLength(e.entries[r]);
  return t;
};

exports.avc1 = exports.VisualSampleEntry = {};

exports.VisualSampleEntry.encode = function(e, t, r) {
  writeReserved(t = t ? t.slice(r) : new Buffer(exports.VisualSampleEntry.encodingLength(e)), 0, 6);
  t.writeUInt16BE(e.dataReferenceIndex || 0, 6);
  writeReserved(t, 8, 24);
  t.writeUInt16BE(e.width || 0, 24);
  t.writeUInt16BE(e.height || 0, 26);
  t.writeUInt32BE(e.hResolution || 4718592, 28);
  t.writeUInt32BE(e.vResolution || 4718592, 32);
  writeReserved(t, 36, 40);
  t.writeUInt16BE(e.frameCount || 1, 40);
  var n = e.compressorName || "", o = Math.min(n.length, 31);
  t.writeUInt8(o, 42);
  t.write(n, 43, o, "utf8");
  t.writeUInt16BE(e.depth || 24, 74);
  t.writeInt16BE(-1, 76);
  var i = 78;
  (e.children || []).forEach(function(e) {
    Box.encode(e, t, i);
    i += Box.encode.bytes;
  });
  exports.VisualSampleEntry.encode.bytes = i;
};

exports.VisualSampleEntry.decode = function(e, t, r) {
  e = e.slice(t);
  for (var n = r - t, o = Math.min(e.readUInt8(42), 31), i = {
    dataReferenceIndex: e.readUInt16BE(6),
    width: e.readUInt16BE(24),
    height: e.readUInt16BE(26),
    hResolution: e.readUInt32BE(28),
    vResolution: e.readUInt32BE(32),
    frameCount: e.readUInt16BE(40),
    compressorName: e.toString("utf8", 43, 43 + o),
    depth: e.readUInt16BE(74),
    children: []
  }, s = 78; n - s >= 8; ) {
    var d = Box.decode(e, s, n);
    i.children.push(d);
    i[d.type] = d;
    s += d.length;
  }
  return i;
};

exports.VisualSampleEntry.encodingLength = function(e) {
  var t = 78;
  (e.children || []).forEach(function(e) {
    t += Box.encodingLength(e);
  });
  return t;
};

exports.avcC = {};

exports.avcC.encode = function(e, t, r) {
  t = t ? t.slice(r) : Buffer(e.buffer.length);
  e.buffer.copy(t);
  exports.avcC.encode.bytes = e.buffer.length;
};

exports.avcC.decode = function(e, t, r) {
  return {
    mimeCodec: (e = e.slice(t, r)).toString("hex", 1, 4),
    buffer: new Buffer(e)
  };
};

exports.avcC.encodingLength = function(e) {
  return e.buffer.length;
};

exports.mp4a = exports.AudioSampleEntry = {};

exports.AudioSampleEntry.encode = function(e, t, r) {
  writeReserved(t = t ? t.slice(r) : new Buffer(exports.AudioSampleEntry.encodingLength(e)), 0, 6);
  t.writeUInt16BE(e.dataReferenceIndex || 0, 6);
  writeReserved(t, 8, 16);
  t.writeUInt16BE(e.channelCount || 2, 16);
  t.writeUInt16BE(e.sampleSize || 16, 18);
  writeReserved(t, 20, 24);
  t.writeUInt32BE(e.sampleRate || 0, 24);
  var n = 28;
  (e.children || []).forEach(function(e) {
    Box.encode(e, t, n);
    n += Box.encode.bytes;
  });
  exports.AudioSampleEntry.encode.bytes = n;
};

exports.AudioSampleEntry.decode = function(e, t, r) {
  for (var n = r - t, o = {
    dataReferenceIndex: (e = e.slice(t, r)).readUInt16BE(6),
    channelCount: e.readUInt16BE(16),
    sampleSize: e.readUInt16BE(18),
    sampleRate: e.readUInt32BE(24),
    children: []
  }, i = 28; n - i >= 8; ) {
    var s = Box.decode(e, i, n);
    o.children.push(s);
    o[s.type] = s;
    i += s.length;
  }
  return o;
};

exports.AudioSampleEntry.encodingLength = function(e) {
  var t = 28;
  (e.children || []).forEach(function(e) {
    t += Box.encodingLength(e);
  });
  return t;
};

exports.esds = {};

exports.esds.encode = function(e, t, r) {
  t = t ? t.slice(r) : Buffer(e.buffer.length);
  e.buffer.copy(t, 0);
  exports.esds.encode.bytes = e.buffer.length;
};

exports.esds.decode = function(e, t, r) {
  e = e.slice(t, r);
  var n = Descriptor.Descriptor.decode(e, 0, e.length), o = ("ESDescriptor" === n.tagName ? n : {}).DecoderConfigDescriptor || {}, i = o.oti || 0, s = o.DecoderSpecificInfo, d = s ? (248 & s.buffer.readUInt8(0)) >> 3 : 0, c = null;
  if (i) {
    c = i.toString(16);
    d && (c += "." + d);
  }
  return {
    mimeCodec: c,
    buffer: new Buffer(e.slice(0))
  };
};

exports.esds.encodingLength = function(e) {
  return e.buffer.length;
};

exports.stsz = {};

exports.stsz.encode = function(e, t, r) {
  var n = e.entries || [];
  (t = t ? t.slice(r) : Buffer(exports.stsz.encodingLength(e))).writeUInt32BE(0, 0);
  t.writeUInt32BE(n.length, 4);
  for (var o = 0; o < n.length; o++) t.writeUInt32BE(n[o], 4 * o + 8);
  exports.stsz.encode.bytes = 8 + 4 * n.length;
  return t;
};

exports.stsz.decode = function(e, t) {
  for (var r = (e = e.slice(t)).readUInt32BE(0), n = e.readUInt32BE(4), o = new Array(n), i = 0; i < n; i++) o[i] = 0 === r ? e.readUInt32BE(4 * i + 8) : r;
  return {
    entries: o
  };
};

exports.stsz.encodingLength = function(e) {
  return 8 + 4 * e.entries.length;
};

exports.stss = exports.stco = {};

exports.stco.encode = function(e, t, r) {
  var n = e.entries || [];
  (t = t ? t.slice(r) : new Buffer(exports.stco.encodingLength(e))).writeUInt32BE(n.length, 0);
  for (var o = 0; o < n.length; o++) t.writeUInt32BE(n[o], 4 * o + 4);
  exports.stco.encode.bytes = 4 + 4 * n.length;
  return t;
};

exports.stco.decode = function(e, t) {
  for (var r = (e = e.slice(t)).readUInt32BE(0), n = new Array(r), o = 0; o < r; o++) n[o] = e.readUInt32BE(4 * o + 4);
  return {
    entries: n
  };
};

exports.stco.encodingLength = function(e) {
  return 4 + 4 * e.entries.length;
};

exports.stts = {};

exports.stts.encode = function(e, t, r) {
  var n = e.entries || [];
  (t = t ? t.slice(r) : new Buffer(exports.stts.encodingLength(e))).writeUInt32BE(n.length, 0);
  for (var o = 0; o < n.length; o++) {
    var i = 8 * o + 4;
    t.writeUInt32BE(n[o].count || 0, i);
    t.writeUInt32BE(n[o].duration || 0, i + 4);
  }
  exports.stts.encode.bytes = 4 + 8 * e.entries.length;
  return t;
};

exports.stts.decode = function(e, t) {
  for (var r = (e = e.slice(t)).readUInt32BE(0), n = new Array(r), o = 0; o < r; o++) {
    var i = 8 * o + 4;
    n[o] = {
      count: e.readUInt32BE(i),
      duration: e.readUInt32BE(i + 4)
    };
  }
  return {
    entries: n
  };
};

exports.stts.encodingLength = function(e) {
  return 4 + 8 * e.entries.length;
};

exports.ctts = {};

exports.ctts.encode = function(e, t, r) {
  var n = e.entries || [];
  (t = t ? t.slice(r) : new Buffer(exports.ctts.encodingLength(e))).writeUInt32BE(n.length, 0);
  for (var o = 0; o < n.length; o++) {
    var i = 8 * o + 4;
    t.writeUInt32BE(n[o].count || 0, i);
    t.writeUInt32BE(n[o].compositionOffset || 0, i + 4);
  }
  exports.ctts.encode.bytes = 4 + 8 * n.length;
  return t;
};

exports.ctts.decode = function(e, t) {
  for (var r = (e = e.slice(t)).readUInt32BE(0), n = new Array(r), o = 0; o < r; o++) {
    var i = 8 * o + 4;
    n[o] = {
      count: e.readUInt32BE(i),
      compositionOffset: e.readInt32BE(i + 4)
    };
  }
  return {
    entries: n
  };
};

exports.ctts.encodingLength = function(e) {
  return 4 + 8 * e.entries.length;
};

exports.stsc = {};

exports.stsc.encode = function(e, t, r) {
  var n = e.entries || [];
  (t = t ? t.slice(r) : new Buffer(exports.stsc.encodingLength(e))).writeUInt32BE(n.length, 0);
  for (var o = 0; o < n.length; o++) {
    var i = 12 * o + 4;
    t.writeUInt32BE(n[o].firstChunk || 0, i);
    t.writeUInt32BE(n[o].samplesPerChunk || 0, i + 4);
    t.writeUInt32BE(n[o].sampleDescriptionId || 0, i + 8);
  }
  exports.stsc.encode.bytes = 4 + 12 * n.length;
  return t;
};

exports.stsc.decode = function(e, t) {
  for (var r = (e = e.slice(t)).readUInt32BE(0), n = new Array(r), o = 0; o < r; o++) {
    var i = 12 * o + 4;
    n[o] = {
      firstChunk: e.readUInt32BE(i),
      samplesPerChunk: e.readUInt32BE(i + 4),
      sampleDescriptionId: e.readUInt32BE(i + 8)
    };
  }
  return {
    entries: n
  };
};

exports.stsc.encodingLength = function(e) {
  return 4 + 12 * e.entries.length;
};

exports.dref = {};

exports.dref.encode = function(e, t, r) {
  t = t ? t.slice(r) : new Buffer(exports.dref.encodingLength(e));
  var n = e.entries || [];
  t.writeUInt32BE(n.length, 0);
  for (var o = 4, i = 0; i < n.length; i++) {
    var s = n[i];
    t.writeUInt32BE((s.buf ? s.buf.length : 0) + 4 + 4, o);
    t.write(s.type, o += 4, 4, "ascii");
    o += 4;
    if (s.buf) {
      s.buf.copy(t, o);
      o += s.buf.length;
    }
  }
  exports.dref.encode.bytes = o;
  return t;
};

exports.dref.decode = function(e, t) {
  for (var r = (e = e.slice(t)).readUInt32BE(0), n = new Array(r), o = 4, i = 0; i < r; i++) {
    var s = e.readUInt32BE(o), d = e.toString("ascii", o + 4, o + 8), c = e.slice(o + 8, o + s);
    o += s;
    n[i] = {
      type: d,
      buf: c
    };
  }
  return {
    entries: n
  };
};

exports.dref.encodingLength = function(e) {
  var t = 4;
  if (!e.entries) return t;
  for (var r = 0; r < e.entries.length; r++) {
    var n = e.entries[r].buf;
    t += (n ? n.length : 0) + 4 + 4;
  }
  return t;
};

exports.elst = {};

exports.elst.encode = function(e, t, r) {
  var n = e.entries || [];
  (t = t ? t.slice(r) : new Buffer(exports.elst.encodingLength(e))).writeUInt32BE(n.length, 0);
  for (var o = 0; o < n.length; o++) {
    var i = 12 * o + 4;
    t.writeUInt32BE(n[o].trackDuration || 0, i);
    t.writeUInt32BE(n[o].mediaTime || 0, i + 4);
    writeFixed32(n[o].mediaRate || 0, t, i + 8);
  }
  exports.elst.encode.bytes = 4 + 12 * n.length;
  return t;
};

exports.elst.decode = function(e, t) {
  for (var r = (e = e.slice(t)).readUInt32BE(0), n = new Array(r), o = 0; o < r; o++) {
    var i = 12 * o + 4;
    n[o] = {
      trackDuration: e.readUInt32BE(i),
      mediaTime: e.readInt32BE(i + 4),
      mediaRate: readFixed32(e, i + 8)
    };
  }
  return {
    entries: n
  };
};

exports.elst.encodingLength = function(e) {
  return 4 + 12 * e.entries.length;
};

exports.hdlr = {};

exports.hdlr.encode = function(e, t, r) {
  t = t ? t.slice(r) : new Buffer(exports.hdlr.encodingLength(e));
  var n = 21 + (e.name || "").length;
  t.fill(0, 0, n);
  t.write(e.handlerType || "", 4, 4, "ascii");
  writeString(e.name || "", t, 20);
  exports.hdlr.encode.bytes = n;
  return t;
};

exports.hdlr.decode = function(e, t, r) {
  return {
    handlerType: (e = e.slice(t)).toString("ascii", 4, 8),
    name: readString(e, 20, r)
  };
};

exports.hdlr.encodingLength = function(e) {
  return 21 + (e.name || "").length;
};

exports.mehd = {};

exports.mehd.encode = function(e, t, r) {
  (t = t ? t.slice(r) : new Buffer(4)).writeUInt32BE(e.fragmentDuration || 0, 0);
  exports.mehd.encode.bytes = 4;
  return t;
};

exports.mehd.decode = function(e, t) {
  return {
    fragmentDuration: (e = e.slice(t)).readUInt32BE(0)
  };
};

exports.mehd.encodingLength = function(e) {
  return 4;
};

exports.trex = {};

exports.trex.encode = function(e, t, r) {
  (t = t ? t.slice(r) : new Buffer(20)).writeUInt32BE(e.trackId || 0, 0);
  t.writeUInt32BE(e.defaultSampleDescriptionIndex || 0, 4);
  t.writeUInt32BE(e.defaultSampleDuration || 0, 8);
  t.writeUInt32BE(e.defaultSampleSize || 0, 12);
  t.writeUInt32BE(e.defaultSampleFlags || 0, 16);
  exports.trex.encode.bytes = 20;
  return t;
};

exports.trex.decode = function(e, t) {
  return {
    trackId: (e = e.slice(t)).readUInt32BE(0),
    defaultSampleDescriptionIndex: e.readUInt32BE(4),
    defaultSampleDuration: e.readUInt32BE(8),
    defaultSampleSize: e.readUInt32BE(12),
    defaultSampleFlags: e.readUInt32BE(16)
  };
};

exports.trex.encodingLength = function(e) {
  return 20;
};

exports.mfhd = {};

exports.mfhd.encode = function(e, t, r) {
  (t = t ? t.slice(r) : new Buffer(4)).writeUInt32BE(e.sequenceNumber || 0, 0);
  exports.mfhd.encode.bytes = 4;
  return t;
};

exports.mfhd.decode = function(e, t) {
  return {
    sequenceNumber: e.readUint32BE(0)
  };
};

exports.mfhd.encodingLength = function(e) {
  return 4;
};

exports.tfhd = {};

exports.tfhd.encode = function(e, t, r) {
  (t = t ? t.slice(r) : new Buffer(4)).writeUInt32BE(e.trackId, 0);
  exports.tfhd.encode.bytes = 4;
  return t;
};

exports.tfhd.decode = function(e, t) {};

exports.tfhd.encodingLength = function(e) {
  return 4;
};

exports.tfdt = {};

exports.tfdt.encode = function(e, t, r) {
  (t = t ? t.slice(r) : new Buffer(4)).writeUInt32BE(e.baseMediaDecodeTime || 0, 0);
  exports.tfdt.encode.bytes = 4;
  return t;
};

exports.tfdt.decode = function(e, t) {};

exports.tfdt.encodingLength = function(e) {
  return 4;
};

exports.trun = {};

exports.trun.encode = function(e, t, r) {
  (t = t ? t.slice(r) : new Buffer(8 + 16 * e.entries.length)).writeUInt32BE(e.entries.length, 0);
  t.writeInt32BE(e.dataOffset, 4);
  for (var n = 8, o = 0; o < e.entries.length; o++) {
    var i = e.entries[o];
    t.writeUInt32BE(i.sampleDuration, n);
    t.writeUInt32BE(i.sampleSize, n += 4);
    t.writeUInt32BE(i.sampleFlags, n += 4);
    t.writeUInt32BE(i.sampleCompositionTimeOffset, n += 4);
    n += 4;
  }
  exports.trun.encode.bytes = n;
};

exports.trun.decode = function(e, t) {};

exports.trun.encodingLength = function(e) {
  return 8 + 16 * e.entries.length;
};

exports.mdat = {};

exports.mdat.encode = function(e, t, r) {
  if (e.buffer) {
    e.buffer.copy(t, r);
    exports.mdat.encode.bytes = e.buffer.length;
  } else exports.mdat.encode.bytes = exports.mdat.encodingLength(e);
};

exports.mdat.decode = function(e, t, r) {
  return {
    buffer: new Buffer(e.slice(t, r))
  };
};

exports.mdat.encodingLength = function(e) {
  return e.buffer ? e.buffer.length : e.contentLength;
};
}).call(this,require("buffer").Buffer)
},{"./descriptor":12,"./index":13,"buffer":6}],12:[function(require,module,exports){
(function (Buffer){
var tagToName = {
  3: "ESDescriptor",
  4: "DecoderConfigDescriptor",
  5: "DecoderSpecificInfo",
  6: "SLConfigDescriptor"
};

exports.Descriptor = {};

exports.Descriptor.decode = function(r, e, o) {
  var t, c = r.readUInt8(e), s = e + 1, p = 0;
  do {
    p = p << 7 | 127 & (t = r.readUInt8(s++));
  } while (128 & t);
  var i, n = tagToName[c];
  (i = exports[n] ? exports[n].decode(r, s, o) : {
    buffer: new Buffer(r.slice(s, s + p))
  }).tag = c;
  i.tagName = n;
  i.length = s - e + p;
  i.contentsLen = p;
  return i;
};

exports.DescriptorArray = {};

exports.DescriptorArray.decode = function(r, e, o) {
  for (var t = e, c = {}; t + 2 <= o; ) {
    var s = exports.Descriptor.decode(r, t, o);
    t += s.length;
    c[tagToName[s.tag] || "Descriptor" + s.tag] = s;
  }
  return c;
};

exports.ESDescriptor = {};

exports.ESDescriptor.decode = function(r, e, o) {
  var t = r.readUInt8(e + 2), c = e + 3;
  128 & t && (c += 2);
  64 & t && (c += r.readUInt8(c) + 1);
  32 & t && (c += 2);
  return exports.DescriptorArray.decode(r, c, o);
};

exports.DecoderConfigDescriptor = {};

exports.DecoderConfigDescriptor.decode = function(r, e, o) {
  var t = r.readUInt8(e), c = exports.DescriptorArray.decode(r, e + 13, o);
  c.oti = t;
  return c;
};
}).call(this,require("buffer").Buffer)
},{"buffer":6}],13:[function(require,module,exports){
(function (Buffer){
var uint64be = require("uint64be"), boxes = require("./boxes"), UINT32_MAX = 4294967295, Box = exports;

Box.boxes = boxes;

var containers = exports.containers = {
  moov: [ "mvhd", "meta", "traks", "mvex" ],
  trak: [ "tkhd", "tref", "trgr", "edts", "meta", "mdia", "udta" ],
  edts: [ "elst" ],
  mdia: [ "mdhd", "hdlr", "elng", "minf" ],
  minf: [ "vmhd", "smhd", "hmhd", "sthd", "nmhd", "dinf", "stbl" ],
  dinf: [ "dref" ],
  stbl: [ "stsd", "stts", "ctts", "cslg", "stsc", "stsz", "stz2", "stco", "co64", "stss", "stsh", "padb", "stdp", "sdtp", "sbgps", "sgpds", "subss", "saizs", "saios" ],
  mvex: [ "mehd", "trexs", "leva" ],
  moof: [ "mfhd", "meta", "trafs" ],
  traf: [ "tfhd", "trun", "sbgps", "sgpds", "subss", "saizs", "saios", "tfdt", "meta" ]
};

Box.encode = function(e, t, n) {
  Box.encodingLength(e);
  n = n || 0;
  t = t || new Buffer(e.length);
  return Box._encode(e, t, n);
};

Box._encode = function(e, t, n) {
  var o = e.type, s = e.length;
  s > UINT32_MAX && (s = 1);
  t.writeUInt32BE(s, n);
  t.write(e.type, n + 4, 4, "ascii");
  var r = n + 8;
  if (1 === s) {
    uint64be.encode(e.length, t, r);
    r += 8;
  }
  if (boxes.fullBoxes[o]) {
    t.writeUInt32BE(e.flags || 0, r);
    t.writeUInt8(e.version || 0, r);
    r += 4;
  }
  if (containers[o]) {
    containers[o].forEach(function(n) {
      if (5 === n.length) {
        var o = e[n] || [];
        n = n.substr(0, 4);
        o.forEach(function(e) {
          Box._encode(e, t, r);
          r += Box.encode.bytes;
        });
      } else if (e[n]) {
        Box._encode(e[n], t, r);
        r += Box.encode.bytes;
      }
    });
    e.otherBoxes && e.otherBoxes.forEach(function(e) {
      Box._encode(e, t, r);
      r += Box.encode.bytes;
    });
  } else if (boxes[o]) {
    var i = boxes[o].encode;
    i(e, t, r);
    r += i.bytes;
  } else {
    if (!e.buffer) throw new Error("Either `type` must be set to a known type (not'" + o + "') or `buffer` must be set");
    e.buffer.copy(t, r);
    r += e.buffer.length;
  }
  Box.encode.bytes = r - n;
  return t;
};

Box.readHeaders = function(e, t, n) {
  t = t || 0;
  if ((n = n || e.length) - t < 8) return 8;
  var o = e.readUInt32BE(t), s = e.toString("ascii", t + 4, t + 8), r = t + 8;
  if (1 === o) {
    if (n - t < 16) return 16;
    o = uint64be.decode(e, r);
    r += 8;
  }
  var i, f;
  if (boxes.fullBoxes[s]) {
    i = e.readUInt8(r);
    f = 16777215 & e.readUInt32BE(r);
    r += 4;
  }
  return {
    length: o,
    headersLen: r - t,
    contentLen: o - (r - t),
    type: s,
    version: i,
    flags: f
  };
};

Box.decode = function(e, t, n) {
  var o = Box.readHeaders(e, t = t || 0, n = n || e.length);
  if (!o || o.length > n - t) throw new Error("Unsupported media format, data too short...");
  return Box.decodeWithoutHeaders(o, e, t + o.headersLen, t + o.length);
};

Box.decodeWithoutHeaders = function(e, t, n, o) {
  n = n || 0;
  o = o || t.length;
  var s = e.type, r = {};
  if (containers[s]) {
    r.otherBoxes = [];
    for (var i = containers[s], f = n; o - f >= 8; ) {
      var d = Box.decode(t, f, o);
      f += d.length;
      if (i.indexOf(d.type) >= 0) r[d.type] = d; else if (i.indexOf(d.type + "s") >= 0) {
        var a = d.type + "s";
        (r[a] = r[a] || []).push(d);
      } else r.otherBoxes.push(d);
    }
  } else boxes[s] ? r = (0, boxes[s].decode)(t, n, o) : r.buffer = new Buffer(t.slice(n, o));
  r.length = e.length;
  r.contentLen = e.contentLen;
  r.type = e.type;
  r.version = e.version;
  r.flags = e.flags;
  return r;
};

Box.encodingLength = function(e) {
  var t = e.type, n = 8;
  boxes.fullBoxes[t] && (n += 4);
  if (containers[t]) {
    containers[t].forEach(function(t) {
      if (5 === t.length) {
        var o = e[t] || [];
        t = t.substr(0, 4);
        o.forEach(function(e) {
          e.type = t;
          n += Box.encodingLength(e);
        });
      } else if (e[t]) {
        var s = e[t];
        s.type = t;
        n += Box.encodingLength(s);
      }
    });
    e.otherBoxes && e.otherBoxes.forEach(function(e) {
      n += Box.encodingLength(e);
    });
  } else if (boxes[t]) n += boxes[t].encodingLength(e); else {
    if (!e.buffer) throw new Error("Either `type` must be set to a known type (not'" + t + "') or `buffer` must be set");
    n += e.buffer.length;
  }
  n > UINT32_MAX && (n += 8);
  e.length = n;
  return n;
};
}).call(this,require("buffer").Buffer)
},{"./boxes":11,"buffer":6,"uint64be":32}],14:[function(require,module,exports){
(function (Buffer){
function Decoder() {
  if (!(this instanceof Decoder)) return new Decoder();
  stream.Writable.call(this);
  this.destroyed = !1;
  this._pending = 0;
  this._missing = 0;
  this._buf = null;
  this._str = null;
  this._cb = null;
  this._ondrain = null;
  this._writeBuffer = null;
  this._writeCb = null;
  this._ondrain = null;
  this._kick();
}

function MediaData(e) {
  this._parent = e;
  this.destroyed = !1;
  stream.PassThrough.call(this);
}

var stream = require("readable-stream"), inherits = require("/bundle/utils").inherit, nextEvent = require("next-event"), Box = require("mp4-box-encoding"), EMPTY = new Buffer(0);

module.exports = Decoder;

inherits(Decoder, stream.Writable);

Decoder.prototype.destroy = function(e) {
  if (!this.destroyed) {
    this.destroyed = !0;
    e && this.emit("error", e);
    this.emit("close");
  }
};

Decoder.prototype._write = function(e, t, i) {
  if (!this.destroyed) {
    for (var r = !this._str || !this._str._writableState.needDrain; e.length && !this.destroyed; ) {
      if (!this._missing) {
        this._writeBuffer = e;
        this._writeCb = i;
        return;
      }
      var s = e.length < this._missing ? e.length : this._missing;
      this._buf ? e.copy(this._buf, this._buf.length - this._missing) : this._str && (r = this._str.write(s === e.length ? e : e.slice(0, s)));
      this._missing -= s;
      if (!this._missing) {
        var n = this._buf, h = this._cb, o = this._str;
        this._buf = this._cb = this._str = this._ondrain = null;
        r = !0;
        o && o.end();
        h && h(n);
      }
      e = s === e.length ? EMPTY : e.slice(s);
    }
    if (!this._pending || this._missing) r ? i() : this._ondrain(i); else {
      this._writeBuffer = e;
      this._writeCb = i;
    }
  }
};

Decoder.prototype._buffer = function(e, t) {
  this._missing = e;
  this._buf = new Buffer(e);
  this._cb = t;
};

Decoder.prototype._stream = function(e, t) {
  var i = this;
  this._missing = e;
  this._str = new MediaData(this);
  this._ondrain = nextEvent(this._str, "drain");
  this._pending++;
  this._str.on("end", function() {
    i._pending--;
    i._kick();
  });
  this._cb = t;
  return this._str;
};

Decoder.prototype._readBox = function() {
  function bufferHeaders(t, i) {
    e._buffer(t, function(t) {
      i = i ? Buffer.concat([ i, t ]) : t;
      var r = Box.readHeaders(i);
      if ("number" == typeof r) bufferHeaders(r - i.length, i); else {
        e._pending++;
        e._headers = r;
        e.emit("box", r);
      }
    });
  }
  var e = this;
  bufferHeaders(8);
};

Decoder.prototype.stream = function() {
  if (!this._headers) throw new Error("this function can only be called once after 'box' is emitted");
  var e = this._headers;
  this._headers = null;
  return this._stream(e.contentLen, null);
};

Decoder.prototype.decode = function(e) {
  var t = this;
  if (!t._headers) throw new Error("this function can only be called once after 'box' is emitted");
  var i = t._headers;
  t._headers = null;
  t._buffer(i.contentLen, function(r) {
    var s = Box.decodeWithoutHeaders(i, r);
    e(s);
    t._pending--;
    t._kick();
  });
};

Decoder.prototype.ignore = function() {
  var e = this;
  if (!e._headers) throw new Error("this function can only be called once after 'box' is emitted");
  var t = e._headers;
  e._headers = null;
  this._missing = t.contentLen;
  this._cb = function() {
    e._pending--;
    e._kick();
  };
};

Decoder.prototype._kick = function() {
  if (!this._pending) {
    this._buf || this._str || this._readBox();
    if (this._writeBuffer) {
      var e = this._writeCb, t = this._writeBuffer;
      this._writeBuffer = null;
      this._writeCb = null;
      this._write(t, null, e);
    }
  }
};

inherits(MediaData, stream.PassThrough);

MediaData.prototype.destroy = function(e) {
  if (!this.destroyed) {
    this.destroyed = !0;
    this._parent.destroy(e);
    e && this.emit("error", e);
    this.emit("close");
  }
};
}).call(this,require("buffer").Buffer)
},{"/bundle/utils":2,"buffer":6,"mp4-box-encoding":13,"next-event":17,"readable-stream":29}],15:[function(require,module,exports){
function noop() {}

function Encoder() {
  if (!(this instanceof Encoder)) return new Encoder();
  stream.Readable.call(this);
  this.destroyed = !1;
  this._reading = !1;
  this._stream = null;
  this._drain = null;
  this._want = !1;
  this._onreadable = function() {
    if (e._want) {
      e._want = !1;
      e._read();
    }
  };
  this._onend = function() {
    e._stream = null;
  };
  var e = this;
}

function MediaData(e) {
  this._parent = e;
  this.destroyed = !1;
  stream.PassThrough.call(this);
}

var stream = require("readable-stream"), inherits = require("/bundle/utils").inherit, Box = require("mp4-box-encoding");

module.exports = Encoder;

var nextTick = require("/bundle/utils").nextTick, Buffer = require("buffer").Buffer;

inherits(Encoder, stream.Readable);

Encoder.prototype.mediaData = Encoder.prototype.mdat = function(e, t) {
  var r = new MediaData(this);
  this.box({
    type: "mdat",
    contentLength: e,
    encodeBufferLen: 8,
    stream: r
  }, t);
  return r;
};

Encoder.prototype.box = function(e, t) {
  t || (t = noop);
  if (this.destroyed) return t(new Error("Encoder is destroyed"));
  var r;
  e.encodeBufferLen && (r = new Buffer(e.encodeBufferLen));
  if (e.stream) {
    e.buffer = null;
    r = Box.encode(e, r);
    this.push(r);
    this._stream = e.stream;
    this._stream.on("readable", this._onreadable);
    this._stream.on("end", this._onend);
    this._stream.on("end", t);
    this._forward();
  } else {
    r = Box.encode(e, r);
    if (this.push(r)) return nextTick(t);
    this._drain = t;
  }
};

Encoder.prototype.destroy = function(e) {
  if (!this.destroyed) {
    this.destroyed = !0;
    this._stream && this._stream.destroy && this._stream.destroy();
    this._stream = null;
    if (this._drain) {
      var t = this._drain;
      this._drain = null;
      t(e);
    }
    e && this.emit("error", e);
    this.emit("close");
  }
};

Encoder.prototype.finalize = function() {
  this.push(null);
};

Encoder.prototype._forward = function() {
  if (this._stream) for (;!this.destroyed; ) {
    var e = this._stream.read();
    if (!e) {
      this._want = !!this._stream;
      return;
    }
    if (!this.push(e)) return;
  }
};

Encoder.prototype._read = function() {
  if (!this._reading && !this.destroyed) {
    this._reading = !0;
    this._stream && this._forward();
    if (this._drain) {
      var e = this._drain;
      this._drain = null;
      e();
    }
    this._reading = !1;
  }
};

inherits(MediaData, stream.PassThrough);

MediaData.prototype.destroy = function(e) {
  if (!this.destroyed) {
    this.destroyed = !0;
    this._parent.destroy(e);
    e && this.emit("error", e);
    this.emit("close");
  }
};
},{"/bundle/utils":2,"buffer":6,"mp4-box-encoding":13,"readable-stream":29}],16:[function(require,module,exports){
exports.decode = require("./decode");

exports.encode = require("./encode");
},{"./decode":14,"./encode":15}],17:[function(require,module,exports){
function nextEvent(n, t) {
  var e = null;
  n.on(t, function(n) {
    if (e) {
      var t = e;
      e = null;
      t(n);
    }
  });
  return function(n) {
    e = n;
  };
}

module.exports = nextEvent;
},{}],18:[function(require,module,exports){
function once(e) {
  var r = function() {
    if (r.called) return r.value;
    r.called = !0;
    return r.value = e.apply(this, arguments);
  };
  r.called = !1;
  return r;
}

function onceStrict(e) {
  var r = function() {
    if (r.called) throw new Error(r.onceError);
    r.called = !0;
    return r.value = e.apply(this, arguments);
  };
  r.onceError = (e.name || "Function wrapped with `once`") + " shouldn't be called more than once";
  r.called = !1;
  return r;
}

var wrappy = require("wrappy");

module.exports = wrappy(once);

module.exports.strict = wrappy(onceStrict);

once.proto = once(function() {
  Object.defineProperty(Function.prototype, "once", {
    value: function() {
      return once(this);
    },
    configurable: !0
  });
  Object.defineProperty(Function.prototype, "onceStrict", {
    value: function() {
      return onceStrict(this);
    },
    configurable: !0
  });
});
},{"wrappy":33}],19:[function(require,module,exports){
var isFS, once = require("once"), eos = require("end-of-stream"), noop = function() {}, isFn = function(r) {
  return "function" == typeof r;
}, isRequest = function(r) {
  return r.setHeader && isFn(r.abort);
}, destroyer = function(r, e, n, o) {
  o = once(o);
  var t = !1;
  r.on("close", function() {
    t = !0;
  });
  eos(r, {
    readable: e,
    writable: n
  }, function(r) {
    if (r) return o(r);
    t = !0;
    o();
  });
  var i = !1;
  return function(e) {
    if (!t && !i) {
      i = !0;
      if (isRequest(r)) return r.abort();
      if (isFn(r.destroy)) return r.destroy();
      o(e || new Error("stream was destroyed"));
    }
  };
}, call = function(r) {
  r();
}, pipe = function(r, e) {
  return r.pipe(e);
}, pump = function() {
  for (var r = arguments.length, e = new Array(r); r--; ) e[r] = arguments[r];
  var n = isFn(e[e.length - 1] || noop) && e.pop() || noop;
  Array.isArray(e[0]) && (e = e[0]);
  if (e.length < 2) throw new Error("pump requires two streams per minimum");
  var o, t = e.map(function(r, i) {
    var u = i < e.length - 1;
    return destroyer(r, u, i > 0, function(r) {
      o || (o = r);
      r && t.forEach(call);
      if (!u) {
        t.forEach(call);
        n(o);
      }
    });
  });
  return e.reduce(pipe);
};

module.exports = pump;
},{"end-of-stream":7,"once":18}],20:[function(require,module,exports){
function RangeSliceStream(e, t) {
  if (!(this instanceof RangeSliceStream)) return new RangeSliceStream(e);
  stream.Writable.call(this, t);
  this.destroyed = !1;
  this._queue = [];
  this._position = e || 0;
  this._cb = null;
  this._buffer = null;
  this._out = null;
}

var inherits = require("/bundle/utils").inherit, stream = require("readable-stream");

module.exports = RangeSliceStream;

inherits(RangeSliceStream, stream.Writable);

RangeSliceStream.prototype._write = function(e, t, i) {
  for (var r = !0; ;) {
    if (this.destroyed) return;
    if (0 === this._queue.length) {
      this._buffer = e;
      this._cb = i;
      return;
    }
    this._buffer = null;
    var s = this._queue[0], n = Math.max(s.start - this._position, 0), a = s.end - this._position;
    if (n >= e.length) {
      this._position += e.length;
      return i(null);
    }
    var l;
    if (a > e.length) {
      this._position += e.length;
      l = 0 === n ? e : e.slice(n);
      r = s.stream.write(l) && r;
      break;
    }
    this._position += a;
    l = 0 === n && a === e.length ? e : e.slice(n, a);
    r = s.stream.write(l) && r;
    s.last && s.stream.end();
    e = e.slice(a);
    this._queue.shift();
  }
  r ? i(null) : s.stream.once("drain", i.bind(null, null));
};

RangeSliceStream.prototype.slice = function(e) {
  var t = this;
  if (t.destroyed) return null;
  e instanceof Array || (e = [ e ]);
  var i = new stream.PassThrough();
  e.forEach(function(r, s) {
    t._queue.push({
      start: r.start,
      end: r.end,
      stream: i,
      last: s === e.length - 1
    });
  });
  t._buffer && t._write(t._buffer, null, t._cb);
  return i;
};

RangeSliceStream.prototype.destroy = function(e) {
  if (!this.destroyed) {
    this.destroyed = !0;
    e && this.emit("error", e);
  }
};
},{"/bundle/utils":2,"readable-stream":29}],21:[function(require,module,exports){
"use strict";

function Duplex(e) {
  if (!(this instanceof Duplex)) return new Duplex(e);
  Readable.call(this, e);
  Writable.call(this, e);
  e && !1 === e.readable && (this.readable = !1);
  e && !1 === e.writable && (this.writable = !1);
  this.allowHalfOpen = !0;
  e && !1 === e.allowHalfOpen && (this.allowHalfOpen = !1);
  this.once("end", onend);
}

function onend() {
  this.allowHalfOpen || this._writableState.ended || processNextTick(onEndNT, this);
}

function onEndNT(e) {
  e.end();
}

function forEach(e, t) {
  for (var r = 0, i = e.length; r < i; r++) t(e[r], r);
}

var processNextTick = require("/bundle/utils").nextTick, objectKeys = Object.keys || function(e) {
  var t = [];
  for (var r in e) t.push(r);
  return t;
};

module.exports = Duplex;

var inherits = require("/bundle/utils").inherit, Readable = require("./_stream_readable"), Writable = require("./_stream_writable");

inherits(Duplex, Readable);

for (var keys = objectKeys(Writable.prototype), v = 0; v < keys.length; v++) {
  var method = keys[v];
  Duplex.prototype[method] || (Duplex.prototype[method] = Writable.prototype[method]);
}

Object.defineProperty(Duplex.prototype, "destroyed", {
  get: function() {
    return void 0 !== this._readableState && void 0 !== this._writableState && this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function(e) {
    if (void 0 !== this._readableState && void 0 !== this._writableState) {
      this._readableState.destroyed = e;
      this._writableState.destroyed = e;
    }
  }
});

Duplex.prototype._destroy = function(e, t) {
  this.push(null);
  this.end();
  processNextTick(t, e);
};
},{"./_stream_readable":23,"./_stream_writable":25,"/bundle/utils":2}],22:[function(require,module,exports){
"use strict";

function PassThrough(r) {
  if (!(this instanceof PassThrough)) return new PassThrough(r);
  Transform.call(this, r);
}

module.exports = PassThrough;

var Transform = require("./_stream_transform"), inherits = require("/bundle/utils").inherit;

inherits(PassThrough, Transform);

PassThrough.prototype._transform = function(r, s, o) {
  o(null, r);
};
},{"./_stream_transform":24,"/bundle/utils":2}],23:[function(require,module,exports){
"use strict";

function prependListener(e, t, n) {
  if ("function" == typeof e.prependListener) return e.prependListener(t, n);
  e._events && e._events[t] ? isArray(e._events[t]) ? e._events[t].unshift(n) : e._events[t] = [ n, e._events[t] ] : e.on(t, n);
}

function ReadableState(e, t) {
  Duplex = Duplex || require("./_stream_duplex");
  this.objectMode = !!(e = e || {}).objectMode;
  t instanceof Duplex && (this.objectMode = this.objectMode || !!e.readableObjectMode);
  var n = e.highWaterMark;
  this.highWaterMark = n || 0 === n ? n : this.objectMode ? 16 : 16384;
  this.highWaterMark = Math.floor(this.highWaterMark);
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = !1;
  this.endEmitted = !1;
  this.reading = !1;
  this.sync = !0;
  this.needReadable = !1;
  this.emittedReadable = !1;
  this.readableListening = !1;
  this.resumeScheduled = !1;
  this.destroyed = !1;
  this.defaultEncoding = e.defaultEncoding || "utf8";
  this.awaitDrain = 0;
  this.readingMore = !1;
  this.decoder = null;
  this.encoding = null;
  if (e.encoding) {
    StringDecoder || (StringDecoder = require("string_decoder/").StringDecoder);
    this.decoder = new StringDecoder(e.encoding);
    this.encoding = e.encoding;
  }
}

function Readable(e) {
  Duplex = Duplex || require("./_stream_duplex");
  if (!(this instanceof Readable)) return new Readable(e);
  this._readableState = new ReadableState(e, this);
  this.readable = !0;
  if (e) {
    "function" == typeof e.read && (this._read = e.read);
    "function" == typeof e.destroy && (this._destroy = e.destroy);
  }
  Stream.call(this);
}

function readableAddChunk(e, t, n, r, i) {
  var a = e._readableState;
  if (null === t) {
    a.reading = !1;
    onEofChunk(e, a);
  } else {
    var d;
    i || (d = chunkInvalid(a, t));
    if (d) e.emit("error", d); else if (a.objectMode || t && t.length > 0) {
      "string" == typeof t || a.objectMode || Object.getPrototypeOf(t) === Buffer.prototype || (t = Buffer.from(t));
      if (r) a.endEmitted ? e.emit("error", new Error("stream.unshift() after end event")) : addChunk(e, a, t, !0); else if (a.ended) e.emit("error", new Error("stream.push() after EOF")); else {
        a.reading = !1;
        if (a.decoder && !n) {
          t = a.decoder.write(t);
          a.objectMode || 0 !== t.length ? addChunk(e, a, t, !1) : maybeReadMore(e, a);
        } else addChunk(e, a, t, !1);
      }
    } else r || (a.reading = !1);
  }
  return needMoreData(a);
}

function addChunk(e, t, n, r) {
  if (t.flowing && 0 === t.length && !t.sync) {
    e.emit("data", n);
    e.read(0);
  } else {
    t.length += t.objectMode ? 1 : n.length;
    r ? t.buffer.unshift(n) : t.buffer.push(n);
    t.needReadable && emitReadable(e);
  }
  maybeReadMore(e, t);
}

function chunkInvalid(e, t) {
  var n;
  _isUint8Array(t) || "string" == typeof t || void 0 === t || e.objectMode || (n = new TypeError("Invalid non-string/buffer chunk"));
  return n;
}

function needMoreData(e) {
  return !e.ended && (e.needReadable || e.length < e.highWaterMark || 0 === e.length);
}

function computeNewHighWaterMark(e) {
  if (e >= MAX_HWM) e = MAX_HWM; else {
    e--;
    e |= e >>> 1;
    e |= e >>> 2;
    e |= e >>> 4;
    e |= e >>> 8;
    e |= e >>> 16;
    e++;
  }
  return e;
}

function howMuchToRead(e, t) {
  if (e <= 0 || 0 === t.length && t.ended) return 0;
  if (t.objectMode) return 1;
  if (e != e) return t.flowing && t.length ? t.buffer.head.data.length : t.length;
  e > t.highWaterMark && (t.highWaterMark = computeNewHighWaterMark(e));
  if (e <= t.length) return e;
  if (!t.ended) {
    t.needReadable = !0;
    return 0;
  }
  return t.length;
}

function onEofChunk(e, t) {
  if (!t.ended) {
    if (t.decoder) {
      var n = t.decoder.end();
      if (n && n.length) {
        t.buffer.push(n);
        t.length += t.objectMode ? 1 : n.length;
      }
    }
    t.ended = !0;
    emitReadable(e);
  }
}

function emitReadable(e) {
  var t = e._readableState;
  t.needReadable = !1;
  if (!t.emittedReadable) {
    debug("emitReadable", t.flowing);
    t.emittedReadable = !0;
    t.sync ? processNextTick(emitReadable_, e) : emitReadable_(e);
  }
}

function emitReadable_(e) {
  debug("emit readable");
  e.emit("readable");
  flow(e);
}

function maybeReadMore(e, t) {
  if (!t.readingMore) {
    t.readingMore = !0;
    processNextTick(maybeReadMore_, e, t);
  }
}

function maybeReadMore_(e, t) {
  for (var n = t.length; !t.reading && !t.flowing && !t.ended && t.length < t.highWaterMark; ) {
    debug("maybeReadMore read 0");
    e.read(0);
    if (n === t.length) break;
    n = t.length;
  }
  t.readingMore = !1;
}

function pipeOnDrain(e) {
  return function() {
    var t = e._readableState;
    debug("pipeOnDrain", t.awaitDrain);
    t.awaitDrain && t.awaitDrain--;
    if (0 === t.awaitDrain && EElistenerCount(e, "data")) {
      t.flowing = !0;
      flow(e);
    }
  };
}

function nReadingNextTick(e) {
  debug("readable nexttick read 0");
  e.read(0);
}

function resume(e, t) {
  if (!t.resumeScheduled) {
    t.resumeScheduled = !0;
    processNextTick(resume_, e, t);
  }
}

function resume_(e, t) {
  if (!t.reading) {
    debug("resume read 0");
    e.read(0);
  }
  t.resumeScheduled = !1;
  t.awaitDrain = 0;
  e.emit("resume");
  flow(e);
  t.flowing && !t.reading && e.read(0);
}

function flow(e) {
  var t = e._readableState;
  debug("flow", t.flowing);
  for (;t.flowing && null !== e.read(); ) ;
}

function fromList(e, t) {
  if (0 === t.length) return null;
  var n;
  if (t.objectMode) n = t.buffer.shift(); else if (!e || e >= t.length) {
    n = t.decoder ? t.buffer.join("") : 1 === t.buffer.length ? t.buffer.head.data : t.buffer.concat(t.length);
    t.buffer.clear();
  } else n = fromListPartial(e, t.buffer, t.decoder);
  return n;
}

function fromListPartial(e, t, n) {
  var r;
  if (e < t.head.data.length) {
    r = t.head.data.slice(0, e);
    t.head.data = t.head.data.slice(e);
  } else r = e === t.head.data.length ? t.shift() : n ? copyFromBufferString(e, t) : copyFromBuffer(e, t);
  return r;
}

function copyFromBufferString(e, t) {
  var n = t.head, r = 1, i = n.data;
  e -= i.length;
  for (;n = n.next; ) {
    var a = n.data, d = e > a.length ? a.length : e;
    i += d === a.length ? a : a.slice(0, e);
    if (0 == (e -= d)) {
      if (d === a.length) {
        ++r;
        t.head = n.next ? n.next : t.tail = null;
      } else {
        t.head = n;
        n.data = a.slice(d);
      }
      break;
    }
    ++r;
  }
  t.length -= r;
  return i;
}

function copyFromBuffer(e, t) {
  var n = Buffer.allocUnsafe(e), r = t.head, i = 1;
  r.data.copy(n);
  e -= r.data.length;
  for (;r = r.next; ) {
    var a = r.data, d = e > a.length ? a.length : e;
    a.copy(n, n.length - e, 0, d);
    if (0 == (e -= d)) {
      if (d === a.length) {
        ++i;
        t.head = r.next ? r.next : t.tail = null;
      } else {
        t.head = r;
        r.data = a.slice(d);
      }
      break;
    }
    ++i;
  }
  t.length -= i;
  return n;
}

function endReadable(e) {
  var t = e._readableState;
  if (t.length > 0) throw new Error('"endReadable()" called on non-empty stream');
  if (!t.endEmitted) {
    t.ended = !0;
    processNextTick(endReadableNT, t, e);
  }
}

function endReadableNT(e, t) {
  if (!e.endEmitted && 0 === e.length) {
    e.endEmitted = !0;
    t.readable = !1;
    t.emit("end");
  }
}

function forEach(e, t) {
  for (var n = 0, r = e.length; n < r; n++) t(e[n], n);
}

function indexOf(e, t) {
  for (var n = 0, r = e.length; n < r; n++) if (e[n] === t) return n;
  return -1;
}

var processNextTick = require("/bundle/utils").nextTick;

module.exports = Readable;

var Duplex, isArray = Array.isArray;

Readable.ReadableState = ReadableState;

var StringDecoder, EE = require("events").EventEmitter, EElistenerCount = function(e, t) {
  return e.listeners(t).length;
}, Stream = require("./internal/streams/stream"), _isUint8Array = require("/bundle/utils").isU8, Buffer = require("buffer").Buffer, inherits = require("/bundle/utils").inherit, debug = require("/bundle/utils").debuglog("stream"), BufferList = require("./internal/streams/BufferList"), destroyImpl = require("./internal/streams/destroy");

inherits(Readable, Stream);

var kProxyEvents = [ "error", "close", "destroy", "pause", "resume" ];

Object.defineProperty(Readable.prototype, "destroyed", {
  get: function() {
    return void 0 !== this._readableState && this._readableState.destroyed;
  },
  set: function(e) {
    this._readableState && (this._readableState.destroyed = e);
  }
});

Readable.prototype.destroy = destroyImpl.destroy;

Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function(e, t) {
  this.push(null);
  t(e);
};

Readable.prototype.push = function(e, t) {
  var n, r = this._readableState;
  if (r.objectMode) n = !0; else if ("string" == typeof e) {
    if ((t = t || r.defaultEncoding) !== r.encoding) {
      e = Buffer.from(e, t);
      t = "";
    }
    n = !0;
  }
  return readableAddChunk(this, e, t, !1, n);
};

Readable.prototype.unshift = function(e) {
  return readableAddChunk(this, e, null, !0, !1);
};

Readable.prototype.isPaused = function() {
  return !1 === this._readableState.flowing;
};

Readable.prototype.setEncoding = function(e) {
  StringDecoder || (StringDecoder = require("string_decoder/").StringDecoder);
  this._readableState.decoder = new StringDecoder(e);
  this._readableState.encoding = e;
  return this;
};

var MAX_HWM = 8388608;

Readable.prototype.read = function(e) {
  debug("read", e);
  e = parseInt(e, 10);
  var t = this._readableState, n = e;
  0 !== e && (t.emittedReadable = !1);
  if (0 === e && t.needReadable && (t.length >= t.highWaterMark || t.ended)) {
    debug("read: emitReadable", t.length, t.ended);
    0 === t.length && t.ended ? endReadable(this) : emitReadable(this);
    return null;
  }
  if (0 === (e = howMuchToRead(e, t)) && t.ended) {
    0 === t.length && endReadable(this);
    return null;
  }
  var r = t.needReadable;
  debug("need readable", r);
  (0 === t.length || t.length - e < t.highWaterMark) && debug("length less than watermark", r = !0);
  if (t.ended || t.reading) debug("reading or ended", r = !1); else if (r) {
    debug("do read");
    t.reading = !0;
    t.sync = !0;
    0 === t.length && (t.needReadable = !0);
    this._read(t.highWaterMark);
    t.sync = !1;
    t.reading || (e = howMuchToRead(n, t));
  }
  var i;
  if (null === (i = e > 0 ? fromList(e, t) : null)) {
    t.needReadable = !0;
    e = 0;
  } else t.length -= e;
  if (0 === t.length) {
    t.ended || (t.needReadable = !0);
    n !== e && t.ended && endReadable(this);
  }
  null !== i && this.emit("data", i);
  return i;
};

Readable.prototype._read = function(e) {
  this.emit("error", new Error("_read() is not implemented"));
};

Readable.prototype.pipe = function(e, t) {
  function onunpipe(t, i) {
    debug("onunpipe");
    if (t === n && i && !1 === i.hasUnpiped) {
      i.hasUnpiped = !0;
      !function() {
        debug("cleanup");
        e.removeListener("close", onclose);
        e.removeListener("finish", onfinish);
        e.removeListener("drain", a);
        e.removeListener("error", onerror);
        e.removeListener("unpipe", onunpipe);
        n.removeListener("end", onend);
        n.removeListener("end", unpipe);
        n.removeListener("data", ondata);
        d = !0;
        !r.awaitDrain || e._writableState && !e._writableState.needDrain || a();
      }();
    }
  }
  function onend() {
    debug("onend");
    e.end();
  }
  function ondata(t) {
    debug("ondata");
    o = !1;
    if (!1 === e.write(t) && !o) {
      if ((1 === r.pipesCount && r.pipes === e || r.pipesCount > 1 && -1 !== indexOf(r.pipes, e)) && !d) {
        debug("false write response, pause", n._readableState.awaitDrain);
        n._readableState.awaitDrain++;
        o = !0;
      }
      n.pause();
    }
  }
  function onerror(t) {
    debug("onerror", t);
    unpipe();
    e.removeListener("error", onerror);
    0 === EElistenerCount(e, "error") && e.emit("error", t);
  }
  function onclose() {
    e.removeListener("finish", onfinish);
    unpipe();
  }
  function onfinish() {
    debug("onfinish");
    e.removeListener("close", onclose);
    unpipe();
  }
  function unpipe() {
    debug("unpipe");
    n.unpipe(e);
  }
  var n = this, r = this._readableState;
  switch (r.pipesCount) {
   case 0:
    r.pipes = e;
    break;

   case 1:
    r.pipes = [ r.pipes, e ];
    break;

   default:
    r.pipes.push(e);
  }
  r.pipesCount += 1;
  debug("pipe count=%d opts=%j", r.pipesCount, t);
  var i = t && !1 === t.end ? unpipe : onend;
  r.endEmitted ? processNextTick(i) : n.once("end", i);
  e.on("unpipe", onunpipe);
  var a = pipeOnDrain(n);
  e.on("drain", a);
  var d = !1, o = !1;
  n.on("data", ondata);
  prependListener(e, "error", onerror);
  e.once("close", onclose);
  e.once("finish", onfinish);
  e.emit("pipe", n);
  if (!r.flowing) {
    debug("pipe resume");
    n.resume();
  }
  return e;
};

Readable.prototype.unpipe = function(e) {
  var t = this._readableState, n = {
    hasUnpiped: !1
  };
  if (0 === t.pipesCount) return this;
  if (1 === t.pipesCount) {
    if (e && e !== t.pipes) return this;
    e || (e = t.pipes);
    t.pipes = null;
    t.pipesCount = 0;
    t.flowing = !1;
    e && e.emit("unpipe", this, n);
    return this;
  }
  if (!e) {
    var r = t.pipes, i = t.pipesCount;
    t.pipes = null;
    t.pipesCount = 0;
    t.flowing = !1;
    for (var a = 0; a < i; a++) r[a].emit("unpipe", this, n);
    return this;
  }
  var d = indexOf(t.pipes, e);
  if (-1 === d) return this;
  t.pipes.splice(d, 1);
  t.pipesCount -= 1;
  1 === t.pipesCount && (t.pipes = t.pipes[0]);
  e.emit("unpipe", this, n);
  return this;
};

Readable.prototype.on = function(e, t) {
  var n = Stream.prototype.on.call(this, e, t);
  if ("data" === e) !1 !== this._readableState.flowing && this.resume(); else if ("readable" === e) {
    var r = this._readableState;
    if (!r.endEmitted && !r.readableListening) {
      r.readableListening = r.needReadable = !0;
      r.emittedReadable = !1;
      r.reading ? r.length && emitReadable(this) : processNextTick(nReadingNextTick, this);
    }
  }
  return n;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.resume = function() {
  var e = this._readableState;
  if (!e.flowing) {
    debug("resume");
    e.flowing = !0;
    resume(this, e);
  }
  return this;
};

Readable.prototype.pause = function() {
  debug("call pause flowing=%j", this._readableState.flowing);
  if (!1 !== this._readableState.flowing) {
    debug("pause");
    this._readableState.flowing = !1;
    this.emit("pause");
  }
  return this;
};

Readable.prototype.wrap = function(e) {
  var t = this._readableState, n = !1, r = this;
  e.on("end", function() {
    debug("wrapped end");
    if (t.decoder && !t.ended) {
      var e = t.decoder.end();
      e && e.length && r.push(e);
    }
    r.push(null);
  });
  e.on("data", function(i) {
    debug("wrapped data");
    t.decoder && (i = t.decoder.write(i));
    if ((!t.objectMode || null !== i && void 0 !== i) && (t.objectMode || i && i.length) && !r.push(i)) {
      n = !0;
      e.pause();
    }
  });
  for (var i in e) void 0 === this[i] && "function" == typeof e[i] && (this[i] = function(t) {
    return function() {
      return e[t].apply(e, arguments);
    };
  }(i));
  for (var a = 0; a < kProxyEvents.length; a++) e.on(kProxyEvents[a], r.emit.bind(r, kProxyEvents[a]));
  r._read = function(t) {
    debug("wrapped _read", t);
    if (n) {
      n = !1;
      e.resume();
    }
  };
  return r;
};

Readable._fromList = fromList;
},{"./_stream_duplex":21,"./internal/streams/BufferList":26,"./internal/streams/destroy":27,"./internal/streams/stream":28,"/bundle/utils":2,"buffer":6,"events":8,"string_decoder/":30}],24:[function(require,module,exports){
"use strict";

function TransformState(r) {
  this.afterTransform = function(t, e) {
    return afterTransform(r, t, e);
  };
  this.needTransform = !1;
  this.transforming = !1;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}

function afterTransform(r, t, e) {
  var n = r._transformState;
  n.transforming = !1;
  var i = n.writecb;
  if (!i) return r.emit("error", new Error("write callback called multiple times"));
  n.writechunk = null;
  n.writecb = null;
  null !== e && void 0 !== e && r.push(e);
  i(t);
  var a = r._readableState;
  a.reading = !1;
  (a.needReadable || a.length < a.highWaterMark) && r._read(a.highWaterMark);
}

function Transform(r) {
  if (!(this instanceof Transform)) return new Transform(r);
  Duplex.call(this, r);
  this._transformState = new TransformState(this);
  var t = this;
  this._readableState.needReadable = !0;
  this._readableState.sync = !1;
  if (r) {
    "function" == typeof r.transform && (this._transform = r.transform);
    "function" == typeof r.flush && (this._flush = r.flush);
  }
  this.once("prefinish", function() {
    "function" == typeof this._flush ? this._flush(function(r, e) {
      done(t, r, e);
    }) : done(t);
  });
}

function done(r, t, e) {
  if (t) return r.emit("error", t);
  null !== e && void 0 !== e && r.push(e);
  var n = r._transformState;
  if (r._writableState.length) throw new Error("Calling transform done when ws.length != 0");
  if (n.transforming) throw new Error("Calling transform done when still transforming");
  return r.push(null);
}

module.exports = Transform;

var Duplex = require("./_stream_duplex"), inherits = require("/bundle/utils").inherit;

inherits(Transform, Duplex);

Transform.prototype.push = function(r, t) {
  this._transformState.needTransform = !1;
  return Duplex.prototype.push.call(this, r, t);
};

Transform.prototype._transform = function(r, t, e) {
  throw new Error("_transform() is not implemented");
};

Transform.prototype._write = function(r, t, e) {
  var n = this._transformState;
  n.writecb = e;
  n.writechunk = r;
  n.writeencoding = t;
  if (!n.transforming) {
    var i = this._readableState;
    (n.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
  }
};

Transform.prototype._read = function(r) {
  var t = this._transformState;
  if (null !== t.writechunk && t.writecb && !t.transforming) {
    t.transforming = !0;
    this._transform(t.writechunk, t.writeencoding, t.afterTransform);
  } else t.needTransform = !0;
};

Transform.prototype._destroy = function(r, t) {
  var e = this;
  Duplex.prototype._destroy.call(this, r, function(r) {
    t(r);
    e.emit("close");
  });
};
},{"./_stream_duplex":21,"/bundle/utils":2}],25:[function(require,module,exports){
"use strict";

function WriteReq(e, t, i) {
  this.chunk = e;
  this.encoding = t;
  this.callback = i;
  this.next = null;
}

function CorkedRequest(e) {
  var t = this;
  this.next = null;
  this.entry = null;
  this.finish = function() {
    onCorkedFinish(t, e);
  };
}

function nop() {}

function WritableState(e, t) {
  Duplex = Duplex || require("./_stream_duplex");
  this.objectMode = !!(e = e || {}).objectMode;
  t instanceof Duplex && (this.objectMode = this.objectMode || !!e.writableObjectMode);
  var i = e.highWaterMark;
  this.highWaterMark = i || 0 === i ? i : this.objectMode ? 16 : 16384;
  this.highWaterMark = Math.floor(this.highWaterMark);
  this.finalCalled = !1;
  this.needDrain = !1;
  this.ending = !1;
  this.ended = !1;
  this.finished = !1;
  this.destroyed = !1;
  this.decodeStrings = !(!1 === e.decodeStrings);
  this.defaultEncoding = e.defaultEncoding || "utf8";
  this.length = 0;
  this.writing = !1;
  this.corked = 0;
  this.sync = !0;
  this.bufferProcessing = !1;
  this.onwrite = function(e) {
    onwrite(t, e);
  };
  this.writecb = null;
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;
  this.pendingcb = 0;
  this.prefinished = !1;
  this.errorEmitted = !1;
  this.bufferedRequestCount = 0;
  this.corkedRequestsFree = new CorkedRequest(this);
}

function Writable(e) {
  Duplex = Duplex || require("./_stream_duplex");
  if (!(realHasInstance.call(Writable, this) || this instanceof Duplex)) return new Writable(e);
  this._writableState = new WritableState(e, this);
  this.writable = !0;
  if (e) {
    "function" == typeof e.write && (this._write = e.write);
    "function" == typeof e.writev && (this._writev = e.writev);
    "function" == typeof e.destroy && (this._destroy = e.destroy);
    "function" == typeof e.final && (this._final = e.final);
  }
  Stream.call(this);
}

function writeAfterEnd(e, t) {
  var i = new Error("write after end");
  e.emit("error", i);
  processNextTick(t, i);
}

function validChunk(e, t, i, r) {
  var n = !0, s = !1;
  null === i ? s = new TypeError("May not write null values to stream") : "string" == typeof i || void 0 === i || t.objectMode || (s = new TypeError("Invalid non-string/buffer chunk"));
  if (s) {
    e.emit("error", s);
    processNextTick(r, s);
    n = !1;
  }
  return n;
}

function decodeChunk(e, t, i) {
  e.objectMode || !1 === e.decodeStrings || "string" != typeof t || (t = Buffer.from(t, i));
  return t;
}

function writeOrBuffer(e, t, i, r, n, s) {
  if (!i) {
    var o = decodeChunk(t, r, n);
    if (r !== o) {
      i = !0;
      n = "buffer";
      r = o;
    }
  }
  var f = t.objectMode ? 1 : r.length;
  t.length += f;
  var a = t.length < t.highWaterMark;
  a || (t.needDrain = !0);
  if (t.writing || t.corked) {
    var u = t.lastBufferedRequest;
    t.lastBufferedRequest = {
      chunk: r,
      encoding: n,
      isBuf: i,
      callback: s,
      next: null
    };
    u ? u.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest;
    t.bufferedRequestCount += 1;
  } else doWrite(e, t, !1, f, r, n, s);
  return a;
}

function doWrite(e, t, i, r, n, s, o) {
  t.writelen = r;
  t.writecb = o;
  t.writing = !0;
  t.sync = !0;
  i ? e._writev(n, t.onwrite) : e._write(n, s, t.onwrite);
  t.sync = !1;
}

function onwriteError(e, t, i, r, n) {
  --t.pendingcb;
  if (i) {
    processNextTick(n, r);
    processNextTick(finishMaybe, e, t);
    e._writableState.errorEmitted = !0;
    e.emit("error", r);
  } else {
    n(r);
    e._writableState.errorEmitted = !0;
    e.emit("error", r);
    finishMaybe(e, t);
  }
}

function onwriteStateUpdate(e) {
  e.writing = !1;
  e.writecb = null;
  e.length -= e.writelen;
  e.writelen = 0;
}

function onwrite(e, t) {
  var i = e._writableState, r = i.sync, n = i.writecb;
  onwriteStateUpdate(i);
  if (t) onwriteError(e, i, r, t, n); else {
    var s = needFinish(i);
    s || i.corked || i.bufferProcessing || !i.bufferedRequest || clearBuffer(e, i);
    r ? asyncWrite(afterWrite, e, i, s, n) : afterWrite(e, i, s, n);
  }
}

function afterWrite(e, t, i, r) {
  i || onwriteDrain(e, t);
  t.pendingcb--;
  r();
  finishMaybe(e, t);
}

function onwriteDrain(e, t) {
  if (0 === t.length && t.needDrain) {
    t.needDrain = !1;
    e.emit("drain");
  }
}

function clearBuffer(e, t) {
  t.bufferProcessing = !0;
  var i = t.bufferedRequest;
  if (e._writev && i && i.next) {
    var r = t.bufferedRequestCount, n = new Array(r), s = t.corkedRequestsFree;
    s.entry = i;
    for (var o = 0, f = !0; i; ) {
      n[o] = i;
      i.isBuf || (f = !1);
      i = i.next;
      o += 1;
    }
    n.allBuffers = f;
    doWrite(e, t, !0, t.length, n, "", s.finish);
    t.pendingcb++;
    t.lastBufferedRequest = null;
    if (s.next) {
      t.corkedRequestsFree = s.next;
      s.next = null;
    } else t.corkedRequestsFree = new CorkedRequest(t);
  } else {
    for (;i; ) {
      var a = i.chunk;
      doWrite(e, t, !1, t.objectMode ? 1 : a.length, a, i.encoding, i.callback);
      i = i.next;
      if (t.writing) break;
    }
    null === i && (t.lastBufferedRequest = null);
  }
  t.bufferedRequestCount = 0;
  t.bufferedRequest = i;
  t.bufferProcessing = !1;
}

function needFinish(e) {
  return e.ending && 0 === e.length && null === e.bufferedRequest && !e.finished && !e.writing;
}

function callFinal(e, t) {
  e._final(function(i) {
    t.pendingcb--;
    i && e.emit("error", i);
    t.prefinished = !0;
    e.emit("prefinish");
    finishMaybe(e, t);
  });
}

function prefinish(e, t) {
  if (!t.prefinished && !t.finalCalled) if ("function" == typeof e._final) {
    t.pendingcb++;
    t.finalCalled = !0;
    processNextTick(callFinal, e, t);
  } else {
    t.prefinished = !0;
    e.emit("prefinish");
  }
}

function finishMaybe(e, t) {
  var i = needFinish(t);
  if (i) {
    prefinish(e, t);
    if (0 === t.pendingcb) {
      t.finished = !0;
      e.emit("finish");
    }
  }
  return i;
}

function endWritable(e, t, i) {
  t.ending = !0;
  finishMaybe(e, t);
  i && (t.finished ? processNextTick(i) : e.once("finish", i));
  t.ended = !0;
  e.writable = !1;
}

function onCorkedFinish(e, t, i) {
  var r = e.entry;
  e.entry = null;
  for (;r; ) {
    var n = r.callback;
    t.pendingcb--;
    n(i);
    r = r.next;
  }
  t.corkedRequestsFree ? t.corkedRequestsFree.next = e : t.corkedRequestsFree = e;
}

var processNextTick = require("/bundle/utils").nextTick;

module.exports = Writable;

var Duplex, asyncWrite = require("/bundle/utils").nextTick;

Writable.WritableState = WritableState;

var inherits = require("/bundle/utils").inherit, deprecate = require("/bundle/utils").deprecate, Stream = require("./internal/streams/stream"), _isUint8Array = require("/bundle/utils").isU8, Buffer = require("buffer").Buffer, destroyImpl = require("./internal/streams/destroy");

inherits(Writable, Stream);

WritableState.prototype.getBuffer = function() {
  for (var e = this.bufferedRequest, t = []; e; ) {
    t.push(e);
    e = e.next;
  }
  return t;
};

!function() {
  try {
    Object.defineProperty(WritableState.prototype, "buffer", {
      get: deprecate(function() {
        return this.getBuffer();
      }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
    });
  } catch (e) {}
}();

var realHasInstance;

if ("function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance]) {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function(e) {
      return !!realHasInstance.call(this, e) || e && e._writableState instanceof WritableState;
    }
  });
} else realHasInstance = function(e) {
  return e instanceof this;
};

Writable.prototype.pipe = function() {
  this.emit("error", new Error("Cannot pipe, not readable"));
};

Writable.prototype.write = function(e, t, i) {
  var r = this._writableState, n = !1, s = _isUint8Array(e) && !r.objectMode;
  s && !Buffer.isBuffer(e) && (e = Buffer.from(e));
  if ("function" == typeof t) {
    i = t;
    t = null;
  }
  s ? t = "buffer" : t || (t = r.defaultEncoding);
  "function" != typeof i && (i = nop);
  if (r.ended) writeAfterEnd(this, i); else if (s || validChunk(this, r, e, i)) {
    r.pendingcb++;
    n = writeOrBuffer(this, r, s, e, t, i);
  }
  return n;
};

Writable.prototype.cork = function() {
  this._writableState.corked++;
};

Writable.prototype.uncork = function() {
  var e = this._writableState;
  if (e.corked) {
    e.corked--;
    e.writing || e.corked || e.finished || e.bufferProcessing || !e.bufferedRequest || clearBuffer(this, e);
  }
};

Writable.prototype.setDefaultEncoding = function(e) {
  "string" == typeof e && (e = e.toLowerCase());
  if (!([ "hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw" ].indexOf((e + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + e);
  this._writableState.defaultEncoding = e;
  return this;
};

Writable.prototype._write = function(e, t, i) {
  i(new Error("_write() is not implemented"));
};

Writable.prototype._writev = null;

Writable.prototype.end = function(e, t, i) {
  var r = this._writableState;
  if ("function" == typeof e) {
    i = e;
    e = null;
    t = null;
  } else if ("function" == typeof t) {
    i = t;
    t = null;
  }
  null !== e && void 0 !== e && this.write(e, t);
  if (r.corked) {
    r.corked = 1;
    this.uncork();
  }
  r.ending || r.finished || endWritable(this, r, i);
};

Object.defineProperty(Writable.prototype, "destroyed", {
  get: function() {
    return void 0 !== this._writableState && this._writableState.destroyed;
  },
  set: function(e) {
    this._writableState && (this._writableState.destroyed = e);
  }
});

Writable.prototype.destroy = destroyImpl.destroy;

Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function(e, t) {
  this.end();
  t(e);
};
},{"./_stream_duplex":21,"./internal/streams/destroy":27,"./internal/streams/stream":28,"/bundle/utils":2,"buffer":6}],26:[function(require,module,exports){
"use strict";

function _classCallCheck(t, e) {
  if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
}

function copyBuffer(t, e, i) {
  t.copy(e, i);
}

var Buffer = require("buffer").Buffer;

module.exports = function() {
  function BufferList() {
    _classCallCheck(this, BufferList);
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  BufferList.prototype.push = function(t) {
    var e = {
      data: t,
      next: null
    };
    this.length > 0 ? this.tail.next = e : this.head = e;
    this.tail = e;
    ++this.length;
  };
  BufferList.prototype.unshift = function(t) {
    var e = {
      data: t,
      next: this.head
    };
    0 === this.length && (this.tail = e);
    this.head = e;
    ++this.length;
  };
  BufferList.prototype.shift = function() {
    if (0 !== this.length) {
      var t = this.head.data;
      this.head = 1 === this.length ? this.tail = null : this.head.next;
      --this.length;
      return t;
    }
  };
  BufferList.prototype.clear = function() {
    this.head = this.tail = null;
    this.length = 0;
  };
  BufferList.prototype.join = function(t) {
    if (0 === this.length) return "";
    for (var e = this.head, i = "" + e.data; e = e.next; ) i += t + e.data;
    return i;
  };
  BufferList.prototype.concat = function(t) {
    if (0 === this.length) return Buffer.alloc(0);
    if (1 === this.length) return this.head.data;
    for (var e = Buffer.allocUnsafe(t >>> 0), i = this.head, n = 0; i; ) {
      copyBuffer(i.data, e, n);
      n += i.data.length;
      i = i.next;
    }
    return e;
  };
  return BufferList;
}();
},{"buffer":6}],27:[function(require,module,exports){
"use strict";

function destroy(t, e) {
  var r = this;
  if (this._readableState && this._readableState.destroyed || this._writableState && this._writableState.destroyed) e ? e(t) : !t || this._writableState && this._writableState.errorEmitted || processNextTick(emitErrorNT, this, t); else {
    this._readableState && (this._readableState.destroyed = !0);
    this._writableState && (this._writableState.destroyed = !0);
    this._destroy(t || null, function(t) {
      if (!e && t) {
        processNextTick(emitErrorNT, r, t);
        r._writableState && (r._writableState.errorEmitted = !0);
      } else e && e(t);
    });
  }
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = !1;
    this._readableState.reading = !1;
    this._readableState.ended = !1;
    this._readableState.endEmitted = !1;
  }
  if (this._writableState) {
    this._writableState.destroyed = !1;
    this._writableState.ended = !1;
    this._writableState.ending = !1;
    this._writableState.finished = !1;
    this._writableState.errorEmitted = !1;
  }
}

function emitErrorNT(t, e) {
  t.emit("error", e);
}

var processNextTick = require("/bundle/utils").nextTick;

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"/bundle/utils":2}],28:[function(require,module,exports){
module.exports = require("events").EventEmitter;
},{"events":8}],29:[function(require,module,exports){
exports = module.exports = require("./lib/_stream_readable.js");

exports.Stream = exports;

exports.Readable = exports;

exports.Writable = require("./lib/_stream_writable.js");

exports.Duplex = require("./lib/_stream_duplex.js");

exports.Transform = require("./lib/_stream_transform.js");

exports.PassThrough = require("./lib/_stream_passthrough.js");
},{"./lib/_stream_duplex.js":21,"./lib/_stream_passthrough.js":22,"./lib/_stream_readable.js":23,"./lib/_stream_transform.js":24,"./lib/_stream_writable.js":25}],30:[function(require,module,exports){
"use strict";

function _normalizeEncoding(t) {
  if (!t) return "utf8";
  for (var e; ;) switch (t) {
   case "utf8":
   case "utf-8":
    return "utf8";

   case "ucs2":
   case "ucs-2":
   case "utf16le":
   case "utf-16le":
    return "utf16le";

   case "latin1":
   case "binary":
    return "latin1";

   case "base64":
   case "ascii":
   case "hex":
    return t;

   default:
    if (e) return;
    t = ("" + t).toLowerCase();
    e = !0;
  }
}

function normalizeEncoding(t) {
  var e = _normalizeEncoding(t);
  if ("string" != typeof e && (Buffer.isEncoding === isEncoding || !isEncoding(t))) throw new Error("Unknown encoding: " + t);
  return e || t;
}

function StringDecoder(t) {
  this.encoding = normalizeEncoding(t);
  var e;
  switch (this.encoding) {
   case "utf16le":
    this.text = utf16Text;
    this.end = utf16End;
    e = 4;
    break;

   case "utf8":
    this.fillLast = utf8FillLast;
    e = 4;
    break;

   case "base64":
    this.text = base64Text;
    this.end = base64End;
    e = 3;
    break;

   default:
    this.write = simpleWrite;
    this.end = simpleEnd;
    return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(e);
}

function utf8CheckByte(t) {
  return t <= 127 ? 0 : t >> 5 == 6 ? 2 : t >> 4 == 14 ? 3 : t >> 3 == 30 ? 4 : -1;
}

function utf8CheckIncomplete(t, e, s) {
  var i = e.length - 1;
  if (i < s) return 0;
  var r = utf8CheckByte(e[i]);
  if (r >= 0) {
    r > 0 && (t.lastNeed = r - 1);
    return r;
  }
  if (--i < s) return 0;
  if ((r = utf8CheckByte(e[i])) >= 0) {
    r > 0 && (t.lastNeed = r - 2);
    return r;
  }
  if (--i < s) return 0;
  if ((r = utf8CheckByte(e[i])) >= 0) {
    r > 0 && (2 === r ? r = 0 : t.lastNeed = r - 3);
    return r;
  }
  return 0;
}

function utf8CheckExtraBytes(t, e, s) {
  if (128 != (192 & e[0])) {
    t.lastNeed = 0;
    return "\ufffd".repeat(s);
  }
  if (t.lastNeed > 1 && e.length > 1) {
    if (128 != (192 & e[1])) {
      t.lastNeed = 1;
      return "\ufffd".repeat(s + 1);
    }
    if (t.lastNeed > 2 && e.length > 2 && 128 != (192 & e[2])) {
      t.lastNeed = 2;
      return "\ufffd".repeat(s + 2);
    }
  }
}

function utf8FillLast(t) {
  var e = this.lastTotal - this.lastNeed, s = utf8CheckExtraBytes(this, t, e);
  if (void 0 !== s) return s;
  if (this.lastNeed <= t.length) {
    t.copy(this.lastChar, e, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  t.copy(this.lastChar, e, 0, t.length);
  this.lastNeed -= t.length;
}

function utf8Text(t, e) {
  var s = utf8CheckIncomplete(this, t, e);
  if (!this.lastNeed) return t.toString("utf8", e);
  this.lastTotal = s;
  var i = t.length - (s - this.lastNeed);
  t.copy(this.lastChar, 0, i);
  return t.toString("utf8", e, i);
}

function utf8End(t) {
  var e = t && t.length ? this.write(t) : "";
  return this.lastNeed ? e + "\ufffd".repeat(this.lastTotal - this.lastNeed) : e;
}

function utf16Text(t, e) {
  if ((t.length - e) % 2 == 0) {
    var s = t.toString("utf16le", e);
    if (s) {
      var i = s.charCodeAt(s.length - 1);
      if (i >= 55296 && i <= 56319) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = t[t.length - 2];
        this.lastChar[1] = t[t.length - 1];
        return s.slice(0, -1);
      }
    }
    return s;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = t[t.length - 1];
  return t.toString("utf16le", e, t.length - 1);
}

function utf16End(t) {
  var e = t && t.length ? this.write(t) : "";
  return this.lastNeed ? e + this.lastChar.toString("utf16le", 0, this.lastTotal - this.lastNeed) : e;
}

function base64Text(t, e) {
  var s = (t.length - e) % 3;
  if (0 === s) return t.toString("base64", e);
  this.lastNeed = 3 - s;
  this.lastTotal = 3;
  if (1 === s) this.lastChar[0] = t[t.length - 1]; else {
    this.lastChar[0] = t[t.length - 2];
    this.lastChar[1] = t[t.length - 1];
  }
  return t.toString("base64", e, t.length - s);
}

function base64End(t) {
  var e = t && t.length ? this.write(t) : "";
  return this.lastNeed ? e + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e;
}

function simpleWrite(t) {
  return t.toString(this.encoding);
}

function simpleEnd(t) {
  return t && t.length ? this.write(t) : "";
}

var Buffer = require("buffer").Buffer, isEncoding = Buffer.isEncoding || function(t) {
  switch ((t = "" + t) && t.toLowerCase()) {
   case "hex":
   case "utf8":
   case "utf-8":
   case "ascii":
   case "binary":
   case "base64":
   case "ucs2":
   case "ucs-2":
   case "utf16le":
   case "utf-16le":
   case "raw":
    return !0;

   default:
    return !1;
  }
};

exports.StringDecoder = StringDecoder;

StringDecoder.prototype.write = function(t) {
  if (0 === t.length) return "";
  var e, s;
  if (this.lastNeed) {
    if (void 0 === (e = this.fillLast(t))) return "";
    s = this.lastNeed;
    this.lastNeed = 0;
  } else s = 0;
  return s < t.length ? e ? e + this.text(t, s) : this.text(t, s) : e || "";
};

StringDecoder.prototype.end = utf8End;

StringDecoder.prototype.text = utf8Text;

StringDecoder.prototype.fillLast = function(t) {
  if (this.lastNeed <= t.length) {
    t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t.length);
  this.lastNeed -= t.length;
};
},{"buffer":6}],31:[function(require,module,exports){
var Buffer = require("buffer").Buffer;

module.exports = function(e) {
  if (e instanceof Uint8Array) {
    if (0 === e.byteOffset && e.byteLength === e.buffer.byteLength) return e.buffer;
    if ("function" == typeof e.buffer.slice) return e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength);
  }
  if (Buffer.isBuffer(e)) {
    for (var f = new Uint8Array(e.length), r = e.length, t = 0; t < r; t++) f[t] = e[t];
    return f.buffer;
  }
  throw new Error("Argument must be a Buffer");
};
},{"buffer":6}],32:[function(require,module,exports){
(function (Buffer){
var UINT_32_MAX = Math.pow(2, 32);

exports.encodingLength = function() {
  return 8;
};

exports.encode = function(e, t, r) {
  t || (t = new Buffer(8));
  r || (r = 0);
  var n = Math.floor(e / UINT_32_MAX), o = e - n * UINT_32_MAX;
  t.writeUInt32BE(n, r);
  t.writeUInt32BE(o, r + 4);
  return t;
};

exports.decode = function(e, t) {
  t || (t = 0);
  e || (e = new Buffer(4));
  t || (t = 0);
  var r = e.readUInt32BE(t), n = e.readUInt32BE(t + 4);
  return r * UINT_32_MAX + n;
};

exports.encode.bytes = 8;

exports.decode.bytes = 8;
}).call(this,require("buffer").Buffer)
},{"buffer":6}],33:[function(require,module,exports){
function wrappy(r, e) {
  function wrapper() {
    for (var e = new Array(arguments.length), n = 0; n < e.length; n++) e[n] = arguments[n];
    var p = r.apply(this, e), t = e[e.length - 1];
    "function" == typeof p && p !== t && Object.keys(t).forEach(function(r) {
      p[r] = t[r];
    });
    return p;
  }
  if (r && e) return wrappy(r)(e);
  if ("function" != typeof r) throw new TypeError("need wrapper function");
  Object.keys(r).forEach(function(e) {
    wrapper[e] = r[e];
  });
  return wrapper;
}

module.exports = wrappy;
},{}],34:[function(require,module,exports){
"use strict";

function VideoStream(e, r, t) {
  var i = this;
  if (!(this instanceof VideoStream)) return new VideoStream(e, r, t);
  t = t || {};
  i.detailedError = null;
  i._elem = r;
  i._elemWrapper = new MediaElementWrapper(r, t);
  i._waitingFired = !1;
  i._trackMeta = null;
  i._file = e;
  i._tracks = null;
  "none" !== i._elem.preload && i._createMuxer();
  i._onError = function(e) {
    i.detailedError = i._elemWrapper.detailedError || e;
    d && console.error("VideoStream Error.", e, i.detailedError);
    i.destroy();
  };
  i._onWaiting = function() {
    i._waitingFired = !0;
    i._muxer ? i._tracks && i._pump() : i._createMuxer();
  };
  i._elem.addEventListener("waiting", i._onWaiting);
  i._elem.addEventListener("error", i._onError);
}

var pump = require("pump"), MP4Remuxer = require("./mp4-remuxer"), MediaElementWrapper = require("mediasource");

module.exports = VideoStream;

VideoStream.prototype = Object.create(null);

VideoStream.prototype._createMuxer = function() {
  var e = this;
  e._muxer = new MP4Remuxer(e._file);
  e._muxer.on("ready", function(r) {
    e._tracks = r.map(function(r) {
      var t = e.createWriteStream(r.mime), i = {
        muxed: null,
        mediaSource: t,
        initFlushed: !1,
        onInitFlushed: null
      };
      t.write(r.init, function(e) {
        i.initFlushed = !0;
        i.onInitFlushed && i.onInitFlushed(e);
      });
      return i;
    });
    (e._waitingFired || "auto" === e._elem.preload) && e._pump();
  });
  e._muxer.on("error", function(r) {
    e._elemWrapper.error(r);
  });
};

VideoStream.prototype.createWriteStream = function(e) {
  var r = this, t = r._elemWrapper.createWriteStream(e), i = t.destroy;
  t.destroy = function(e) {
    try {
      i.apply(t, arguments);
    } catch (t) {
      var r = this, o = this._sourceBuffer;
      d && console.debug('Caught exception ("%s")', t.name, o && o.updating, o, t);
      if (!o || !o.updating) throw t;
      e && r.emit("error", e);
      r.emit("close");
    }
  };
  t.on("error", function(e) {
    r._elemWrapper.error(e);
  });
  return t;
};

VideoStream.prototype._pump = function() {
  try {
    this._unsafePump();
  } catch (e) {
    this._onError(e);
  }
};

VideoStream.prototype._unsafePump = function() {
  var e = this, r = e._muxer.seek(e._elem.currentTime, !e._tracks);
  e._tracks.forEach(function(t, i) {
    var o = function() {
      if (t.muxed) {
        t.muxed.destroy();
        t.mediaSource = e.createWriteStream(t.mediaSource);
      }
      t.muxed = r[i];
      pump(t.muxed, t.mediaSource);
    };
    t.initFlushed ? o() : t.onInitFlushed = function(r) {
      r ? e._elemWrapper.error(r) : o();
    };
  });
};

VideoStream.prototype.destroy = function() {
  if (!this.destroyed) {
    this.destroyed = !0;
    this._elem.removeEventListener("waiting", this._onWaiting);
    this._elem.removeEventListener("error", this._onError);
    if (this._tracks) {
      var e, r, t = this._tracks;
      for (e = t.length; e--; ) {
        r = t[e];
        try {
          r.muxed && r.muxed.destroy();
        } catch (e) {
          console.warn(r, e);
        }
      }
    }
    String(this._elem.src).startsWith("blob:") && URL.revokeObjectURL(this._elem.src);
    this._elem.src = "";
    this._elem = !1;
  }
};

VideoStream.prototype.forEachSourceBuffer = function(e) {
  if (this._tracks) {
    var r, t, i, o, n, a = this._elem.currentTime;
    for (r = this._tracks.length; r--; ) {
      n = this._tracks[r].mediaSource._mediaSource;
      i = (t = this._tracks[r].mediaSource._sourceBuffer).buffered.length ? t.buffered.start(0) : 0;
      o = t.buffered.length ? t.buffered.end(t.buffered.length - 1) : 0;
      try {
        e.call(this, t, i, o, a, n);
      } catch (e) {
        console.debug(e);
      }
    }
  }
};

VideoStream.prototype.flushSourceBuffers = function() {
  this.forEachSourceBuffer(function(e, r, t, i, o) {
    d && console.debug("seeking ct=%s sr=%s er=%s", i, r, t, e.updating, o.readyState, e);
    if (!e.updating) {
      t > i ? r = Math.max(i + 1, r) : i >= r && i <= t && (t = i - 1);
      if (t > r) {
        e.remove(r, t);
        d && console.log("seeking flushed", r, t);
      }
    }
  });
};

Object.defineProperty(VideoStream.prototype, "bufTime", {
  get: function() {
    var e = this._muxer._tracks[0] || !1, r = e && e.samples[e.currSample] || !1;
    return (r.dts + r.duration) / e.timeScale - this._elem.currentTime;
  }
});
},{"./mp4-remuxer":3,"mediasource":10,"pump":19}]},{},[1]);
